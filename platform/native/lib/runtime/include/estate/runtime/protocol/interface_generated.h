// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INTERFACE_H_
#define FLATBUFFERS_GENERATED_INTERFACE_H_

#include "flatbuffers/flatbuffers.h"

#include "model_generated.h"

struct CallServiceMethodRequestProto;
struct CallServiceMethodRequestProtoBuilder;

struct CallServiceMethodResponseProto;
struct CallServiceMethodResponseProtoBuilder;

struct ErrorCodeResponseProto;
struct ErrorCodeResponseProtoBuilder;

struct ExceptionResponseProto;
struct ExceptionResponseProtoBuilder;

struct GetDataRequestProto;
struct GetDataRequestProtoBuilder;

struct GetDataResponseProto;
struct GetDataResponseProtoBuilder;

struct MessageMessageProto;
struct MessageMessageProtoBuilder;

struct DataUpdateMessageProto;
struct DataUpdateMessageProtoBuilder;

struct UserMessageUnionWrapperProto;
struct UserMessageUnionWrapperProtoBuilder;

struct UserMessageUnionWrapperBytesProto;
struct UserMessageUnionWrapperBytesProtoBuilder;

struct RiverUserMessageProto;
struct RiverUserMessageProtoBuilder;

struct UserResponseUnionWrapperProto;
struct UserResponseUnionWrapperProtoBuilder;

struct UserResponseUnionWrapperBytesProto;
struct UserResponseUnionWrapperBytesProtoBuilder;

struct RiverUserResponseProto;
struct RiverUserResponseProtoBuilder;

struct SaveDataRequestProto;
struct SaveDataRequestProtoBuilder;

struct SaveDataResponseProto;
struct SaveDataResponseProtoBuilder;

struct SubscribeMessageRequestProto;
struct SubscribeMessageRequestProtoBuilder;

struct SubscribeMessageResponseProto;
struct SubscribeMessageResponseProtoBuilder;

struct SubscribeDataUpdatesRequestProto;
struct SubscribeDataUpdatesRequestProtoBuilder;

struct SubscribeDataUpdatesResponseProto;
struct SubscribeDataUpdatesResponseProtoBuilder;

struct UnsubscribeMessageRequestProto;
struct UnsubscribeMessageRequestProtoBuilder;

struct UnsubscribeMessageResponseProto;
struct UnsubscribeMessageResponseProtoBuilder;

struct UnsubscribeDataUpdatesRequestProto;
struct UnsubscribeDataUpdatesRequestProtoBuilder;

struct UnsubscribeDataUpdatesResponseProto;
struct UnsubscribeDataUpdatesResponseProtoBuilder;

struct UserRequestProto;
struct UserRequestProtoBuilder;

enum class UserMessageUnionProto : uint8_t {
  NONE = 0,
  DataUpdateMessageProto = 1,
  MessageMessageProto = 2,
  MIN = NONE,
  MAX = MessageMessageProto
};

inline const UserMessageUnionProto (&EnumValuesUserMessageUnionProto())[3] {
  static const UserMessageUnionProto values[] = {
    UserMessageUnionProto::NONE,
    UserMessageUnionProto::DataUpdateMessageProto,
    UserMessageUnionProto::MessageMessageProto
  };
  return values;
}

inline const char * const *EnumNamesUserMessageUnionProto() {
  static const char * const names[4] = {
    "NONE",
    "DataUpdateMessageProto",
    "MessageMessageProto",
    nullptr
  };
  return names;
}

inline const char *EnumNameUserMessageUnionProto(UserMessageUnionProto e) {
  if (flatbuffers::IsOutRange(e, UserMessageUnionProto::NONE, UserMessageUnionProto::MessageMessageProto)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUserMessageUnionProto()[index];
}

template<typename T> struct UserMessageUnionProtoTraits {
  static const UserMessageUnionProto enum_value = UserMessageUnionProto::NONE;
};

template<> struct UserMessageUnionProtoTraits<DataUpdateMessageProto> {
  static const UserMessageUnionProto enum_value = UserMessageUnionProto::DataUpdateMessageProto;
};

template<> struct UserMessageUnionProtoTraits<MessageMessageProto> {
  static const UserMessageUnionProto enum_value = UserMessageUnionProto::MessageMessageProto;
};

bool VerifyUserMessageUnionProto(flatbuffers::Verifier &verifier, const void *obj, UserMessageUnionProto type);
bool VerifyUserMessageUnionProtoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class UserResponseUnionProto : uint8_t {
  NONE = 0,
  ErrorCodeResponseProto = 1,
  ExceptionResponseProto = 2,
  CallServiceMethodResponseProto = 3,
  GetDataResponseProto = 4,
  SaveDataResponseProto = 5,
  SubscribeMessageResponseProto = 6,
  UnsubscribeMessageResponseProto = 7,
  SubscribeDataUpdatesResponseProto = 8,
  UnsubscribeDataUpdatesResponseProto = 9,
  MIN = NONE,
  MAX = UnsubscribeDataUpdatesResponseProto
};

inline const UserResponseUnionProto (&EnumValuesUserResponseUnionProto())[10] {
  static const UserResponseUnionProto values[] = {
    UserResponseUnionProto::NONE,
    UserResponseUnionProto::ErrorCodeResponseProto,
    UserResponseUnionProto::ExceptionResponseProto,
    UserResponseUnionProto::CallServiceMethodResponseProto,
    UserResponseUnionProto::GetDataResponseProto,
    UserResponseUnionProto::SaveDataResponseProto,
    UserResponseUnionProto::SubscribeMessageResponseProto,
    UserResponseUnionProto::UnsubscribeMessageResponseProto,
    UserResponseUnionProto::SubscribeDataUpdatesResponseProto,
    UserResponseUnionProto::UnsubscribeDataUpdatesResponseProto
  };
  return values;
}

inline const char * const *EnumNamesUserResponseUnionProto() {
  static const char * const names[11] = {
    "NONE",
    "ErrorCodeResponseProto",
    "ExceptionResponseProto",
    "CallServiceMethodResponseProto",
    "GetDataResponseProto",
    "SaveDataResponseProto",
    "SubscribeMessageResponseProto",
    "UnsubscribeMessageResponseProto",
    "SubscribeDataUpdatesResponseProto",
    "UnsubscribeDataUpdatesResponseProto",
    nullptr
  };
  return names;
}

inline const char *EnumNameUserResponseUnionProto(UserResponseUnionProto e) {
  if (flatbuffers::IsOutRange(e, UserResponseUnionProto::NONE, UserResponseUnionProto::UnsubscribeDataUpdatesResponseProto)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUserResponseUnionProto()[index];
}

template<typename T> struct UserResponseUnionProtoTraits {
  static const UserResponseUnionProto enum_value = UserResponseUnionProto::NONE;
};

template<> struct UserResponseUnionProtoTraits<ErrorCodeResponseProto> {
  static const UserResponseUnionProto enum_value = UserResponseUnionProto::ErrorCodeResponseProto;
};

template<> struct UserResponseUnionProtoTraits<ExceptionResponseProto> {
  static const UserResponseUnionProto enum_value = UserResponseUnionProto::ExceptionResponseProto;
};

template<> struct UserResponseUnionProtoTraits<CallServiceMethodResponseProto> {
  static const UserResponseUnionProto enum_value = UserResponseUnionProto::CallServiceMethodResponseProto;
};

template<> struct UserResponseUnionProtoTraits<GetDataResponseProto> {
  static const UserResponseUnionProto enum_value = UserResponseUnionProto::GetDataResponseProto;
};

template<> struct UserResponseUnionProtoTraits<SaveDataResponseProto> {
  static const UserResponseUnionProto enum_value = UserResponseUnionProto::SaveDataResponseProto;
};

template<> struct UserResponseUnionProtoTraits<SubscribeMessageResponseProto> {
  static const UserResponseUnionProto enum_value = UserResponseUnionProto::SubscribeMessageResponseProto;
};

template<> struct UserResponseUnionProtoTraits<UnsubscribeMessageResponseProto> {
  static const UserResponseUnionProto enum_value = UserResponseUnionProto::UnsubscribeMessageResponseProto;
};

template<> struct UserResponseUnionProtoTraits<SubscribeDataUpdatesResponseProto> {
  static const UserResponseUnionProto enum_value = UserResponseUnionProto::SubscribeDataUpdatesResponseProto;
};

template<> struct UserResponseUnionProtoTraits<UnsubscribeDataUpdatesResponseProto> {
  static const UserResponseUnionProto enum_value = UserResponseUnionProto::UnsubscribeDataUpdatesResponseProto;
};

bool VerifyUserResponseUnionProto(flatbuffers::Verifier &verifier, const void *obj, UserResponseUnionProto type);
bool VerifyUserResponseUnionProtoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class UserRequestUnionProto : uint8_t {
  NONE = 0,
  CallServiceMethodRequestProto = 1,
  GetDataRequestProto = 2,
  SaveDataRequestProto = 3,
  SubscribeMessageRequestProto = 4,
  UnsubscribeMessageRequestProto = 5,
  SubscribeDataUpdatesRequestProto = 6,
  UnsubscribeDataUpdatesRequestProto = 7,
  MIN = NONE,
  MAX = UnsubscribeDataUpdatesRequestProto
};

inline const UserRequestUnionProto (&EnumValuesUserRequestUnionProto())[8] {
  static const UserRequestUnionProto values[] = {
    UserRequestUnionProto::NONE,
    UserRequestUnionProto::CallServiceMethodRequestProto,
    UserRequestUnionProto::GetDataRequestProto,
    UserRequestUnionProto::SaveDataRequestProto,
    UserRequestUnionProto::SubscribeMessageRequestProto,
    UserRequestUnionProto::UnsubscribeMessageRequestProto,
    UserRequestUnionProto::SubscribeDataUpdatesRequestProto,
    UserRequestUnionProto::UnsubscribeDataUpdatesRequestProto
  };
  return values;
}

inline const char * const *EnumNamesUserRequestUnionProto() {
  static const char * const names[9] = {
    "NONE",
    "CallServiceMethodRequestProto",
    "GetDataRequestProto",
    "SaveDataRequestProto",
    "SubscribeMessageRequestProto",
    "UnsubscribeMessageRequestProto",
    "SubscribeDataUpdatesRequestProto",
    "UnsubscribeDataUpdatesRequestProto",
    nullptr
  };
  return names;
}

inline const char *EnumNameUserRequestUnionProto(UserRequestUnionProto e) {
  if (flatbuffers::IsOutRange(e, UserRequestUnionProto::NONE, UserRequestUnionProto::UnsubscribeDataUpdatesRequestProto)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUserRequestUnionProto()[index];
}

template<typename T> struct UserRequestUnionProtoTraits {
  static const UserRequestUnionProto enum_value = UserRequestUnionProto::NONE;
};

template<> struct UserRequestUnionProtoTraits<CallServiceMethodRequestProto> {
  static const UserRequestUnionProto enum_value = UserRequestUnionProto::CallServiceMethodRequestProto;
};

template<> struct UserRequestUnionProtoTraits<GetDataRequestProto> {
  static const UserRequestUnionProto enum_value = UserRequestUnionProto::GetDataRequestProto;
};

template<> struct UserRequestUnionProtoTraits<SaveDataRequestProto> {
  static const UserRequestUnionProto enum_value = UserRequestUnionProto::SaveDataRequestProto;
};

template<> struct UserRequestUnionProtoTraits<SubscribeMessageRequestProto> {
  static const UserRequestUnionProto enum_value = UserRequestUnionProto::SubscribeMessageRequestProto;
};

template<> struct UserRequestUnionProtoTraits<UnsubscribeMessageRequestProto> {
  static const UserRequestUnionProto enum_value = UserRequestUnionProto::UnsubscribeMessageRequestProto;
};

template<> struct UserRequestUnionProtoTraits<SubscribeDataUpdatesRequestProto> {
  static const UserRequestUnionProto enum_value = UserRequestUnionProto::SubscribeDataUpdatesRequestProto;
};

template<> struct UserRequestUnionProtoTraits<UnsubscribeDataUpdatesRequestProto> {
  static const UserRequestUnionProto enum_value = UserRequestUnionProto::UnsubscribeDataUpdatesRequestProto;
};

bool VerifyUserRequestUnionProto(flatbuffers::Verifier &verifier, const void *obj, UserRequestUnionProto type);
bool VerifyUserRequestUnionProtoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct CallServiceMethodRequestProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallServiceMethodRequestProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_PRIMARY_KEY = 6,
    VT_METHOD_ID = 8,
    VT_ARGUMENTS = 10,
    VT_REFERENCED_DATA_DELTAS = 12
  };
  uint16_t class_id() const {
    return GetField<uint16_t>(VT_CLASS_ID, 0);
  }
  const flatbuffers::String *primary_key() const {
    return GetPointer<const flatbuffers::String *>(VT_PRIMARY_KEY);
  }
  uint16_t method_id() const {
    return GetField<uint16_t>(VT_METHOD_ID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ValueProto>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ValueProto>> *>(VT_ARGUMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<InboundDataDeltaProto>> *referenced_data_deltas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<InboundDataDeltaProto>> *>(VT_REFERENCED_DATA_DELTAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CLASS_ID) &&
           VerifyOffsetRequired(verifier, VT_PRIMARY_KEY) &&
           verifier.VerifyString(primary_key()) &&
           VerifyField<uint16_t>(verifier, VT_METHOD_ID) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           VerifyOffset(verifier, VT_REFERENCED_DATA_DELTAS) &&
           verifier.VerifyVector(referenced_data_deltas()) &&
           verifier.VerifyVectorOfTables(referenced_data_deltas()) &&
           verifier.EndTable();
  }
};

struct CallServiceMethodRequestProtoBuilder {
  typedef CallServiceMethodRequestProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_class_id(uint16_t class_id) {
    fbb_.AddElement<uint16_t>(CallServiceMethodRequestProto::VT_CLASS_ID, class_id, 0);
  }
  void add_primary_key(flatbuffers::Offset<flatbuffers::String> primary_key) {
    fbb_.AddOffset(CallServiceMethodRequestProto::VT_PRIMARY_KEY, primary_key);
  }
  void add_method_id(uint16_t method_id) {
    fbb_.AddElement<uint16_t>(CallServiceMethodRequestProto::VT_METHOD_ID, method_id, 0);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ValueProto>>> arguments) {
    fbb_.AddOffset(CallServiceMethodRequestProto::VT_ARGUMENTS, arguments);
  }
  void add_referenced_data_deltas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<InboundDataDeltaProto>>> referenced_data_deltas) {
    fbb_.AddOffset(CallServiceMethodRequestProto::VT_REFERENCED_DATA_DELTAS, referenced_data_deltas);
  }
  explicit CallServiceMethodRequestProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CallServiceMethodRequestProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallServiceMethodRequestProto>(end);
    fbb_.Required(o, CallServiceMethodRequestProto::VT_PRIMARY_KEY);
    return o;
  }
};

inline flatbuffers::Offset<CallServiceMethodRequestProto> CreateCallServiceMethodRequestProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    flatbuffers::Offset<flatbuffers::String> primary_key = 0,
    uint16_t method_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ValueProto>>> arguments = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<InboundDataDeltaProto>>> referenced_data_deltas = 0) {
  CallServiceMethodRequestProtoBuilder builder_(_fbb);
  builder_.add_referenced_data_deltas(referenced_data_deltas);
  builder_.add_arguments(arguments);
  builder_.add_primary_key(primary_key);
  builder_.add_method_id(method_id);
  builder_.add_class_id(class_id);
  return builder_.Finish();
}

struct CallServiceMethodRequestProto::Traits {
  using type = CallServiceMethodRequestProto;
  static auto constexpr Create = CreateCallServiceMethodRequestProto;
};

inline flatbuffers::Offset<CallServiceMethodRequestProto> CreateCallServiceMethodRequestProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    const char *primary_key = nullptr,
    uint16_t method_id = 0,
    const std::vector<flatbuffers::Offset<ValueProto>> *arguments = nullptr,
    const std::vector<flatbuffers::Offset<InboundDataDeltaProto>> *referenced_data_deltas = nullptr) {
  auto primary_key__ = primary_key ? _fbb.CreateString(primary_key) : 0;
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<ValueProto>>(*arguments) : 0;
  auto referenced_data_deltas__ = referenced_data_deltas ? _fbb.CreateVector<flatbuffers::Offset<InboundDataDeltaProto>>(*referenced_data_deltas) : 0;
  return CreateCallServiceMethodRequestProto(
      _fbb,
      class_id,
      primary_key__,
      method_id,
      arguments__,
      referenced_data_deltas__);
}

struct CallServiceMethodResponseProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallServiceMethodResponseProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RETURN_VALUE = 4
  };
  const ValueProto *return_value() const {
    return GetPointer<const ValueProto *>(VT_RETURN_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RETURN_VALUE) &&
           verifier.VerifyTable(return_value()) &&
           verifier.EndTable();
  }
};

struct CallServiceMethodResponseProtoBuilder {
  typedef CallServiceMethodResponseProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_return_value(flatbuffers::Offset<ValueProto> return_value) {
    fbb_.AddOffset(CallServiceMethodResponseProto::VT_RETURN_VALUE, return_value);
  }
  explicit CallServiceMethodResponseProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CallServiceMethodResponseProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallServiceMethodResponseProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallServiceMethodResponseProto> CreateCallServiceMethodResponseProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ValueProto> return_value = 0) {
  CallServiceMethodResponseProtoBuilder builder_(_fbb);
  builder_.add_return_value(return_value);
  return builder_.Finish();
}

struct CallServiceMethodResponseProto::Traits {
  using type = CallServiceMethodResponseProto;
  static auto constexpr Create = CreateCallServiceMethodResponseProto;
};

struct ErrorCodeResponseProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErrorCodeResponseProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
};

struct ErrorCodeResponseProtoBuilder {
  typedef ErrorCodeResponseProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(ErrorCodeResponseProto::VT_ERROR_CODE, error_code, 0);
  }
  explicit ErrorCodeResponseProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ErrorCodeResponseProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ErrorCodeResponseProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<ErrorCodeResponseProto> CreateErrorCodeResponseProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0) {
  ErrorCodeResponseProtoBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

struct ErrorCodeResponseProto::Traits {
  using type = ErrorCodeResponseProto;
  static auto constexpr Create = CreateErrorCodeResponseProto;
};

struct ExceptionResponseProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExceptionResponseProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STACK = 4,
    VT_MESSAGE = 6
  };
  const flatbuffers::String *stack() const {
    return GetPointer<const flatbuffers::String *>(VT_STACK);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STACK) &&
           verifier.VerifyString(stack()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ExceptionResponseProtoBuilder {
  typedef ExceptionResponseProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stack(flatbuffers::Offset<flatbuffers::String> stack) {
    fbb_.AddOffset(ExceptionResponseProto::VT_STACK, stack);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(ExceptionResponseProto::VT_MESSAGE, message);
  }
  explicit ExceptionResponseProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExceptionResponseProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExceptionResponseProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExceptionResponseProto> CreateExceptionResponseProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> stack = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  ExceptionResponseProtoBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_stack(stack);
  return builder_.Finish();
}

struct ExceptionResponseProto::Traits {
  using type = ExceptionResponseProto;
  static auto constexpr Create = CreateExceptionResponseProto;
};

inline flatbuffers::Offset<ExceptionResponseProto> CreateExceptionResponseProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *stack = nullptr,
    const char *message = nullptr) {
  auto stack__ = stack ? _fbb.CreateString(stack) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return CreateExceptionResponseProto(
      _fbb,
      stack__,
      message__);
}

struct GetDataRequestProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetDataRequestProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_PRIMARY_KEY = 6
  };
  uint16_t class_id() const {
    return GetField<uint16_t>(VT_CLASS_ID, 0);
  }
  const flatbuffers::String *primary_key() const {
    return GetPointer<const flatbuffers::String *>(VT_PRIMARY_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CLASS_ID) &&
           VerifyOffsetRequired(verifier, VT_PRIMARY_KEY) &&
           verifier.VerifyString(primary_key()) &&
           verifier.EndTable();
  }
};

struct GetDataRequestProtoBuilder {
  typedef GetDataRequestProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_class_id(uint16_t class_id) {
    fbb_.AddElement<uint16_t>(GetDataRequestProto::VT_CLASS_ID, class_id, 0);
  }
  void add_primary_key(flatbuffers::Offset<flatbuffers::String> primary_key) {
    fbb_.AddOffset(GetDataRequestProto::VT_PRIMARY_KEY, primary_key);
  }
  explicit GetDataRequestProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetDataRequestProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetDataRequestProto>(end);
    fbb_.Required(o, GetDataRequestProto::VT_PRIMARY_KEY);
    return o;
  }
};

inline flatbuffers::Offset<GetDataRequestProto> CreateGetDataRequestProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    flatbuffers::Offset<flatbuffers::String> primary_key = 0) {
  GetDataRequestProtoBuilder builder_(_fbb);
  builder_.add_primary_key(primary_key);
  builder_.add_class_id(class_id);
  return builder_.Finish();
}

struct GetDataRequestProto::Traits {
  using type = GetDataRequestProto;
  static auto constexpr Create = CreateGetDataRequestProto;
};

inline flatbuffers::Offset<GetDataRequestProto> CreateGetDataRequestProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    const char *primary_key = nullptr) {
  auto primary_key__ = primary_key ? _fbb.CreateString(primary_key) : 0;
  return CreateGetDataRequestProto(
      _fbb,
      class_id,
      primary_key__);
}

struct GetDataResponseProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetDataResponseProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<NestedDataProto>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NestedDataProto>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct GetDataResponseProtoBuilder {
  typedef GetDataResponseProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NestedDataProto>>> data) {
    fbb_.AddOffset(GetDataResponseProto::VT_DATA, data);
  }
  explicit GetDataResponseProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GetDataResponseProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetDataResponseProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetDataResponseProto> CreateGetDataResponseProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NestedDataProto>>> data = 0) {
  GetDataResponseProtoBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

struct GetDataResponseProto::Traits {
  using type = GetDataResponseProto;
  static auto constexpr Create = CreateGetDataResponseProto;
};

inline flatbuffers::Offset<GetDataResponseProto> CreateGetDataResponseProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<NestedDataProto>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<NestedDataProto>>(*data) : 0;
  return CreateGetDataResponseProto(
      _fbb,
      data__);
}

struct MessageMessageProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageMessageProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT = 4,
    VT_DELTAS = 6
  };
  const MessageBytesProto *event() const {
    return GetPointer<const MessageBytesProto *>(VT_EVENT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DataDeltaBytesProto>> *deltas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DataDeltaBytesProto>> *>(VT_DELTAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_EVENT) &&
           verifier.VerifyTable(event()) &&
           VerifyOffset(verifier, VT_DELTAS) &&
           verifier.VerifyVector(deltas()) &&
           verifier.VerifyVectorOfTables(deltas()) &&
           verifier.EndTable();
  }
};

struct MessageMessageProtoBuilder {
  typedef MessageMessageProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_event(flatbuffers::Offset<MessageBytesProto> event) {
    fbb_.AddOffset(MessageMessageProto::VT_EVENT, event);
  }
  void add_deltas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataDeltaBytesProto>>> deltas) {
    fbb_.AddOffset(MessageMessageProto::VT_DELTAS, deltas);
  }
  explicit MessageMessageProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MessageMessageProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageMessageProto>(end);
    fbb_.Required(o, MessageMessageProto::VT_EVENT);
    return o;
  }
};

inline flatbuffers::Offset<MessageMessageProto> CreateMessageMessageProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<MessageBytesProto> event = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataDeltaBytesProto>>> deltas = 0) {
  MessageMessageProtoBuilder builder_(_fbb);
  builder_.add_deltas(deltas);
  builder_.add_event(event);
  return builder_.Finish();
}

struct MessageMessageProto::Traits {
  using type = MessageMessageProto;
  static auto constexpr Create = CreateMessageMessageProto;
};

inline flatbuffers::Offset<MessageMessageProto> CreateMessageMessageProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<MessageBytesProto> event = 0,
    const std::vector<flatbuffers::Offset<DataDeltaBytesProto>> *deltas = nullptr) {
  auto deltas__ = deltas ? _fbb.CreateVector<flatbuffers::Offset<DataDeltaBytesProto>>(*deltas) : 0;
  return CreateMessageMessageProto(
      _fbb,
      event,
      deltas__);
}

struct DataUpdateMessageProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataUpdateMessageProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DELTAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DataDeltaBytesProto>> *deltas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DataDeltaBytesProto>> *>(VT_DELTAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DELTAS) &&
           verifier.VerifyVector(deltas()) &&
           verifier.VerifyVectorOfTables(deltas()) &&
           verifier.EndTable();
  }
};

struct DataUpdateMessageProtoBuilder {
  typedef DataUpdateMessageProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deltas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataDeltaBytesProto>>> deltas) {
    fbb_.AddOffset(DataUpdateMessageProto::VT_DELTAS, deltas);
  }
  explicit DataUpdateMessageProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataUpdateMessageProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataUpdateMessageProto>(end);
    fbb_.Required(o, DataUpdateMessageProto::VT_DELTAS);
    return o;
  }
};

inline flatbuffers::Offset<DataUpdateMessageProto> CreateDataUpdateMessageProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataDeltaBytesProto>>> deltas = 0) {
  DataUpdateMessageProtoBuilder builder_(_fbb);
  builder_.add_deltas(deltas);
  return builder_.Finish();
}

struct DataUpdateMessageProto::Traits {
  using type = DataUpdateMessageProto;
  static auto constexpr Create = CreateDataUpdateMessageProto;
};

inline flatbuffers::Offset<DataUpdateMessageProto> CreateDataUpdateMessageProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DataDeltaBytesProto>> *deltas = nullptr) {
  auto deltas__ = deltas ? _fbb.CreateVector<flatbuffers::Offset<DataDeltaBytesProto>>(*deltas) : 0;
  return CreateDataUpdateMessageProto(
      _fbb,
      deltas__);
}

struct UserMessageUnionWrapperProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UserMessageUnionWrapperProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  UserMessageUnionProto value_type() const {
    return static_cast<UserMessageUnionProto>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const DataUpdateMessageProto *value_as_DataUpdateMessageProto() const {
    return value_type() == UserMessageUnionProto::DataUpdateMessageProto ? static_cast<const DataUpdateMessageProto *>(value()) : nullptr;
  }
  const MessageMessageProto *value_as_MessageMessageProto() const {
    return value_type() == UserMessageUnionProto::MessageMessageProto ? static_cast<const MessageMessageProto *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyUserMessageUnionProto(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const DataUpdateMessageProto *UserMessageUnionWrapperProto::value_as<DataUpdateMessageProto>() const {
  return value_as_DataUpdateMessageProto();
}

template<> inline const MessageMessageProto *UserMessageUnionWrapperProto::value_as<MessageMessageProto>() const {
  return value_as_MessageMessageProto();
}

struct UserMessageUnionWrapperProtoBuilder {
  typedef UserMessageUnionWrapperProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(UserMessageUnionProto value_type) {
    fbb_.AddElement<uint8_t>(UserMessageUnionWrapperProto::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(UserMessageUnionWrapperProto::VT_VALUE, value);
  }
  explicit UserMessageUnionWrapperProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UserMessageUnionWrapperProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserMessageUnionWrapperProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserMessageUnionWrapperProto> CreateUserMessageUnionWrapperProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    UserMessageUnionProto value_type = UserMessageUnionProto::NONE,
    flatbuffers::Offset<void> value = 0) {
  UserMessageUnionWrapperProtoBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct UserMessageUnionWrapperProto::Traits {
  using type = UserMessageUnionWrapperProto;
  static auto constexpr Create = CreateUserMessageUnionWrapperProto;
};

struct UserMessageUnionWrapperBytesProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UserMessageUnionWrapperBytesProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BYTES = 4
  };
  const flatbuffers::Vector<uint8_t> *bytes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BYTES);
  }
  const UserMessageUnionWrapperProto *bytes_nested_root() const {
    return flatbuffers::GetRoot<UserMessageUnionWrapperProto>(bytes()->Data());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BYTES) &&
           verifier.VerifyVector(bytes()) &&
           verifier.EndTable();
  }
};

struct UserMessageUnionWrapperBytesProtoBuilder {
  typedef UserMessageUnionWrapperBytesProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bytes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes) {
    fbb_.AddOffset(UserMessageUnionWrapperBytesProto::VT_BYTES, bytes);
  }
  explicit UserMessageUnionWrapperBytesProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UserMessageUnionWrapperBytesProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserMessageUnionWrapperBytesProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserMessageUnionWrapperBytesProto> CreateUserMessageUnionWrapperBytesProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes = 0) {
  UserMessageUnionWrapperBytesProtoBuilder builder_(_fbb);
  builder_.add_bytes(bytes);
  return builder_.Finish();
}

struct UserMessageUnionWrapperBytesProto::Traits {
  using type = UserMessageUnionWrapperBytesProto;
  static auto constexpr Create = CreateUserMessageUnionWrapperBytesProto;
};

inline flatbuffers::Offset<UserMessageUnionWrapperBytesProto> CreateUserMessageUnionWrapperBytesProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *bytes = nullptr) {
  auto bytes__ = bytes ? _fbb.CreateVector<uint8_t>(*bytes) : 0;
  return CreateUserMessageUnionWrapperBytesProto(
      _fbb,
      bytes__);
}

struct RiverUserMessageProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RiverUserMessageProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOG_CONTEXT = 4,
    VT_WORKER_ID = 6,
    VT_WORKER_VERSION = 8,
    VT_MESSAGE = 10
  };
  const flatbuffers::String *log_context() const {
    return GetPointer<const flatbuffers::String *>(VT_LOG_CONTEXT);
  }
  uint64_t worker_id() const {
    return GetField<uint64_t>(VT_WORKER_ID, 0);
  }
  uint64_t worker_version() const {
    return GetField<uint64_t>(VT_WORKER_VERSION, 0);
  }
  const UserMessageUnionWrapperBytesProto *message() const {
    return GetPointer<const UserMessageUnionWrapperBytesProto *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LOG_CONTEXT) &&
           verifier.VerifyString(log_context()) &&
           VerifyField<uint64_t>(verifier, VT_WORKER_ID) &&
           VerifyField<uint64_t>(verifier, VT_WORKER_VERSION) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyTable(message()) &&
           verifier.EndTable();
  }
};

struct RiverUserMessageProtoBuilder {
  typedef RiverUserMessageProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_log_context(flatbuffers::Offset<flatbuffers::String> log_context) {
    fbb_.AddOffset(RiverUserMessageProto::VT_LOG_CONTEXT, log_context);
  }
  void add_worker_id(uint64_t worker_id) {
    fbb_.AddElement<uint64_t>(RiverUserMessageProto::VT_WORKER_ID, worker_id, 0);
  }
  void add_worker_version(uint64_t worker_version) {
    fbb_.AddElement<uint64_t>(RiverUserMessageProto::VT_WORKER_VERSION, worker_version, 0);
  }
  void add_message(flatbuffers::Offset<UserMessageUnionWrapperBytesProto> message) {
    fbb_.AddOffset(RiverUserMessageProto::VT_MESSAGE, message);
  }
  explicit RiverUserMessageProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RiverUserMessageProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RiverUserMessageProto>(end);
    fbb_.Required(o, RiverUserMessageProto::VT_LOG_CONTEXT);
    return o;
  }
};

inline flatbuffers::Offset<RiverUserMessageProto> CreateRiverUserMessageProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> log_context = 0,
    uint64_t worker_id = 0,
    uint64_t worker_version = 0,
    flatbuffers::Offset<UserMessageUnionWrapperBytesProto> message = 0) {
  RiverUserMessageProtoBuilder builder_(_fbb);
  builder_.add_worker_version(worker_version);
  builder_.add_worker_id(worker_id);
  builder_.add_message(message);
  builder_.add_log_context(log_context);
  return builder_.Finish();
}

struct RiverUserMessageProto::Traits {
  using type = RiverUserMessageProto;
  static auto constexpr Create = CreateRiverUserMessageProto;
};

inline flatbuffers::Offset<RiverUserMessageProto> CreateRiverUserMessageProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *log_context = nullptr,
    uint64_t worker_id = 0,
    uint64_t worker_version = 0,
    flatbuffers::Offset<UserMessageUnionWrapperBytesProto> message = 0) {
  auto log_context__ = log_context ? _fbb.CreateString(log_context) : 0;
  return CreateRiverUserMessageProto(
      _fbb,
      log_context__,
      worker_id,
      worker_version,
      message);
}

struct UserResponseUnionWrapperProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UserResponseUnionWrapperProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  UserResponseUnionProto value_type() const {
    return static_cast<UserResponseUnionProto>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ErrorCodeResponseProto *value_as_ErrorCodeResponseProto() const {
    return value_type() == UserResponseUnionProto::ErrorCodeResponseProto ? static_cast<const ErrorCodeResponseProto *>(value()) : nullptr;
  }
  const ExceptionResponseProto *value_as_ExceptionResponseProto() const {
    return value_type() == UserResponseUnionProto::ExceptionResponseProto ? static_cast<const ExceptionResponseProto *>(value()) : nullptr;
  }
  const CallServiceMethodResponseProto *value_as_CallServiceMethodResponseProto() const {
    return value_type() == UserResponseUnionProto::CallServiceMethodResponseProto ? static_cast<const CallServiceMethodResponseProto *>(value()) : nullptr;
  }
  const GetDataResponseProto *value_as_GetDataResponseProto() const {
    return value_type() == UserResponseUnionProto::GetDataResponseProto ? static_cast<const GetDataResponseProto *>(value()) : nullptr;
  }
  const SaveDataResponseProto *value_as_SaveDataResponseProto() const {
    return value_type() == UserResponseUnionProto::SaveDataResponseProto ? static_cast<const SaveDataResponseProto *>(value()) : nullptr;
  }
  const SubscribeMessageResponseProto *value_as_SubscribeMessageResponseProto() const {
    return value_type() == UserResponseUnionProto::SubscribeMessageResponseProto ? static_cast<const SubscribeMessageResponseProto *>(value()) : nullptr;
  }
  const UnsubscribeMessageResponseProto *value_as_UnsubscribeMessageResponseProto() const {
    return value_type() == UserResponseUnionProto::UnsubscribeMessageResponseProto ? static_cast<const UnsubscribeMessageResponseProto *>(value()) : nullptr;
  }
  const SubscribeDataUpdatesResponseProto *value_as_SubscribeDataUpdatesResponseProto() const {
    return value_type() == UserResponseUnionProto::SubscribeDataUpdatesResponseProto ? static_cast<const SubscribeDataUpdatesResponseProto *>(value()) : nullptr;
  }
  const UnsubscribeDataUpdatesResponseProto *value_as_UnsubscribeDataUpdatesResponseProto() const {
    return value_type() == UserResponseUnionProto::UnsubscribeDataUpdatesResponseProto ? static_cast<const UnsubscribeDataUpdatesResponseProto *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyUserResponseUnionProto(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ErrorCodeResponseProto *UserResponseUnionWrapperProto::value_as<ErrorCodeResponseProto>() const {
  return value_as_ErrorCodeResponseProto();
}

template<> inline const ExceptionResponseProto *UserResponseUnionWrapperProto::value_as<ExceptionResponseProto>() const {
  return value_as_ExceptionResponseProto();
}

template<> inline const CallServiceMethodResponseProto *UserResponseUnionWrapperProto::value_as<CallServiceMethodResponseProto>() const {
  return value_as_CallServiceMethodResponseProto();
}

template<> inline const GetDataResponseProto *UserResponseUnionWrapperProto::value_as<GetDataResponseProto>() const {
  return value_as_GetDataResponseProto();
}

template<> inline const SaveDataResponseProto *UserResponseUnionWrapperProto::value_as<SaveDataResponseProto>() const {
  return value_as_SaveDataResponseProto();
}

template<> inline const SubscribeMessageResponseProto *UserResponseUnionWrapperProto::value_as<SubscribeMessageResponseProto>() const {
  return value_as_SubscribeMessageResponseProto();
}

template<> inline const UnsubscribeMessageResponseProto *UserResponseUnionWrapperProto::value_as<UnsubscribeMessageResponseProto>() const {
  return value_as_UnsubscribeMessageResponseProto();
}

template<> inline const SubscribeDataUpdatesResponseProto *UserResponseUnionWrapperProto::value_as<SubscribeDataUpdatesResponseProto>() const {
  return value_as_SubscribeDataUpdatesResponseProto();
}

template<> inline const UnsubscribeDataUpdatesResponseProto *UserResponseUnionWrapperProto::value_as<UnsubscribeDataUpdatesResponseProto>() const {
  return value_as_UnsubscribeDataUpdatesResponseProto();
}

struct UserResponseUnionWrapperProtoBuilder {
  typedef UserResponseUnionWrapperProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(UserResponseUnionProto value_type) {
    fbb_.AddElement<uint8_t>(UserResponseUnionWrapperProto::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(UserResponseUnionWrapperProto::VT_VALUE, value);
  }
  explicit UserResponseUnionWrapperProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UserResponseUnionWrapperProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserResponseUnionWrapperProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserResponseUnionWrapperProto> CreateUserResponseUnionWrapperProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    UserResponseUnionProto value_type = UserResponseUnionProto::NONE,
    flatbuffers::Offset<void> value = 0) {
  UserResponseUnionWrapperProtoBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct UserResponseUnionWrapperProto::Traits {
  using type = UserResponseUnionWrapperProto;
  static auto constexpr Create = CreateUserResponseUnionWrapperProto;
};

struct UserResponseUnionWrapperBytesProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UserResponseUnionWrapperBytesProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BYTES = 4
  };
  const flatbuffers::Vector<uint8_t> *bytes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BYTES);
  }
  const UserResponseUnionWrapperProto *bytes_nested_root() const {
    return flatbuffers::GetRoot<UserResponseUnionWrapperProto>(bytes()->Data());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BYTES) &&
           verifier.VerifyVector(bytes()) &&
           verifier.EndTable();
  }
};

struct UserResponseUnionWrapperBytesProtoBuilder {
  typedef UserResponseUnionWrapperBytesProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bytes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes) {
    fbb_.AddOffset(UserResponseUnionWrapperBytesProto::VT_BYTES, bytes);
  }
  explicit UserResponseUnionWrapperBytesProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UserResponseUnionWrapperBytesProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserResponseUnionWrapperBytesProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserResponseUnionWrapperBytesProto> CreateUserResponseUnionWrapperBytesProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes = 0) {
  UserResponseUnionWrapperBytesProtoBuilder builder_(_fbb);
  builder_.add_bytes(bytes);
  return builder_.Finish();
}

struct UserResponseUnionWrapperBytesProto::Traits {
  using type = UserResponseUnionWrapperBytesProto;
  static auto constexpr Create = CreateUserResponseUnionWrapperBytesProto;
};

inline flatbuffers::Offset<UserResponseUnionWrapperBytesProto> CreateUserResponseUnionWrapperBytesProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *bytes = nullptr) {
  auto bytes__ = bytes ? _fbb.CreateVector<uint8_t>(*bytes) : 0;
  return CreateUserResponseUnionWrapperBytesProto(
      _fbb,
      bytes__);
}

struct RiverUserResponseProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RiverUserResponseProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESPONSE = 4,
    VT_MESSAGES = 6,
    VT_CONSOLE_LOG = 8
  };
  const UserResponseUnionWrapperBytesProto *response() const {
    return GetPointer<const UserResponseUnionWrapperBytesProto *>(VT_RESPONSE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<UserMessageUnionWrapperBytesProto>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UserMessageUnionWrapperBytesProto>> *>(VT_MESSAGES);
  }
  const ConsoleLogBytesProto *console_log() const {
    return GetPointer<const ConsoleLogBytesProto *>(VT_CONSOLE_LOG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESPONSE) &&
           verifier.VerifyTable(response()) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           VerifyOffset(verifier, VT_CONSOLE_LOG) &&
           verifier.VerifyTable(console_log()) &&
           verifier.EndTable();
  }
};

struct RiverUserResponseProtoBuilder {
  typedef RiverUserResponseProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_response(flatbuffers::Offset<UserResponseUnionWrapperBytesProto> response) {
    fbb_.AddOffset(RiverUserResponseProto::VT_RESPONSE, response);
  }
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserMessageUnionWrapperBytesProto>>> messages) {
    fbb_.AddOffset(RiverUserResponseProto::VT_MESSAGES, messages);
  }
  void add_console_log(flatbuffers::Offset<ConsoleLogBytesProto> console_log) {
    fbb_.AddOffset(RiverUserResponseProto::VT_CONSOLE_LOG, console_log);
  }
  explicit RiverUserResponseProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RiverUserResponseProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RiverUserResponseProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<RiverUserResponseProto> CreateRiverUserResponseProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<UserResponseUnionWrapperBytesProto> response = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserMessageUnionWrapperBytesProto>>> messages = 0,
    flatbuffers::Offset<ConsoleLogBytesProto> console_log = 0) {
  RiverUserResponseProtoBuilder builder_(_fbb);
  builder_.add_console_log(console_log);
  builder_.add_messages(messages);
  builder_.add_response(response);
  return builder_.Finish();
}

struct RiverUserResponseProto::Traits {
  using type = RiverUserResponseProto;
  static auto constexpr Create = CreateRiverUserResponseProto;
};

inline flatbuffers::Offset<RiverUserResponseProto> CreateRiverUserResponseProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<UserResponseUnionWrapperBytesProto> response = 0,
    const std::vector<flatbuffers::Offset<UserMessageUnionWrapperBytesProto>> *messages = nullptr,
    flatbuffers::Offset<ConsoleLogBytesProto> console_log = 0) {
  auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<UserMessageUnionWrapperBytesProto>>(*messages) : 0;
  return CreateRiverUserResponseProto(
      _fbb,
      response,
      messages__,
      console_log);
}

struct SaveDataRequestProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SaveDataRequestProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_DELTAS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<InboundDataDeltaProto>> *data_deltas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<InboundDataDeltaProto>> *>(VT_DATA_DELTAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA_DELTAS) &&
           verifier.VerifyVector(data_deltas()) &&
           verifier.VerifyVectorOfTables(data_deltas()) &&
           verifier.EndTable();
  }
};

struct SaveDataRequestProtoBuilder {
  typedef SaveDataRequestProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_deltas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<InboundDataDeltaProto>>> data_deltas) {
    fbb_.AddOffset(SaveDataRequestProto::VT_DATA_DELTAS, data_deltas);
  }
  explicit SaveDataRequestProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SaveDataRequestProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SaveDataRequestProto>(end);
    fbb_.Required(o, SaveDataRequestProto::VT_DATA_DELTAS);
    return o;
  }
};

inline flatbuffers::Offset<SaveDataRequestProto> CreateSaveDataRequestProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<InboundDataDeltaProto>>> data_deltas = 0) {
  SaveDataRequestProtoBuilder builder_(_fbb);
  builder_.add_data_deltas(data_deltas);
  return builder_.Finish();
}

struct SaveDataRequestProto::Traits {
  using type = SaveDataRequestProto;
  static auto constexpr Create = CreateSaveDataRequestProto;
};

inline flatbuffers::Offset<SaveDataRequestProto> CreateSaveDataRequestProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<InboundDataDeltaProto>> *data_deltas = nullptr) {
  auto data_deltas__ = data_deltas ? _fbb.CreateVector<flatbuffers::Offset<InboundDataDeltaProto>>(*data_deltas) : 0;
  return CreateSaveDataRequestProto(
      _fbb,
      data_deltas__);
}

struct SaveDataResponseProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SaveDataResponseProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HANDLES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DataHandleProto>> *handles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DataHandleProto>> *>(VT_HANDLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HANDLES) &&
           verifier.VerifyVector(handles()) &&
           verifier.VerifyVectorOfTables(handles()) &&
           verifier.EndTable();
  }
};

struct SaveDataResponseProtoBuilder {
  typedef SaveDataResponseProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_handles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataHandleProto>>> handles) {
    fbb_.AddOffset(SaveDataResponseProto::VT_HANDLES, handles);
  }
  explicit SaveDataResponseProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SaveDataResponseProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SaveDataResponseProto>(end);
    fbb_.Required(o, SaveDataResponseProto::VT_HANDLES);
    return o;
  }
};

inline flatbuffers::Offset<SaveDataResponseProto> CreateSaveDataResponseProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataHandleProto>>> handles = 0) {
  SaveDataResponseProtoBuilder builder_(_fbb);
  builder_.add_handles(handles);
  return builder_.Finish();
}

struct SaveDataResponseProto::Traits {
  using type = SaveDataResponseProto;
  static auto constexpr Create = CreateSaveDataResponseProto;
};

inline flatbuffers::Offset<SaveDataResponseProto> CreateSaveDataResponseProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DataHandleProto>> *handles = nullptr) {
  auto handles__ = handles ? _fbb.CreateVector<flatbuffers::Offset<DataHandleProto>>(*handles) : 0;
  return CreateSaveDataResponseProto(
      _fbb,
      handles__);
}

struct SubscribeMessageRequestProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubscribeMessageRequestProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_SOURCE_TYPE = 6,
    VT_SOURCE = 8
  };
  uint16_t class_id() const {
    return GetField<uint16_t>(VT_CLASS_ID, 0);
  }
  WorkerReferenceUnionProto source_type() const {
    return static_cast<WorkerReferenceUnionProto>(GetField<uint8_t>(VT_SOURCE_TYPE, 0));
  }
  const void *source() const {
    return GetPointer<const void *>(VT_SOURCE);
  }
  template<typename T> const T *source_as() const;
  const DataReferenceValueProto *source_as_DataReferenceValueProto() const {
    return source_type() == WorkerReferenceUnionProto::DataReferenceValueProto ? static_cast<const DataReferenceValueProto *>(source()) : nullptr;
  }
  const ServiceReferenceValueProto *source_as_ServiceReferenceValueProto() const {
    return source_type() == WorkerReferenceUnionProto::ServiceReferenceValueProto ? static_cast<const ServiceReferenceValueProto *>(source()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CLASS_ID) &&
           VerifyField<uint8_t>(verifier, VT_SOURCE_TYPE) &&
           VerifyOffsetRequired(verifier, VT_SOURCE) &&
           VerifyWorkerReferenceUnionProto(verifier, source(), source_type()) &&
           verifier.EndTable();
  }
};

template<> inline const DataReferenceValueProto *SubscribeMessageRequestProto::source_as<DataReferenceValueProto>() const {
  return source_as_DataReferenceValueProto();
}

template<> inline const ServiceReferenceValueProto *SubscribeMessageRequestProto::source_as<ServiceReferenceValueProto>() const {
  return source_as_ServiceReferenceValueProto();
}

struct SubscribeMessageRequestProtoBuilder {
  typedef SubscribeMessageRequestProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_class_id(uint16_t class_id) {
    fbb_.AddElement<uint16_t>(SubscribeMessageRequestProto::VT_CLASS_ID, class_id, 0);
  }
  void add_source_type(WorkerReferenceUnionProto source_type) {
    fbb_.AddElement<uint8_t>(SubscribeMessageRequestProto::VT_SOURCE_TYPE, static_cast<uint8_t>(source_type), 0);
  }
  void add_source(flatbuffers::Offset<void> source) {
    fbb_.AddOffset(SubscribeMessageRequestProto::VT_SOURCE, source);
  }
  explicit SubscribeMessageRequestProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubscribeMessageRequestProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubscribeMessageRequestProto>(end);
    fbb_.Required(o, SubscribeMessageRequestProto::VT_SOURCE);
    return o;
  }
};

inline flatbuffers::Offset<SubscribeMessageRequestProto> CreateSubscribeMessageRequestProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    WorkerReferenceUnionProto source_type = WorkerReferenceUnionProto::NONE,
    flatbuffers::Offset<void> source = 0) {
  SubscribeMessageRequestProtoBuilder builder_(_fbb);
  builder_.add_source(source);
  builder_.add_class_id(class_id);
  builder_.add_source_type(source_type);
  return builder_.Finish();
}

struct SubscribeMessageRequestProto::Traits {
  using type = SubscribeMessageRequestProto;
  static auto constexpr Create = CreateSubscribeMessageRequestProto;
};

struct SubscribeMessageResponseProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubscribeMessageResponseProtoBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SubscribeMessageResponseProtoBuilder {
  typedef SubscribeMessageResponseProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SubscribeMessageResponseProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubscribeMessageResponseProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubscribeMessageResponseProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubscribeMessageResponseProto> CreateSubscribeMessageResponseProto(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SubscribeMessageResponseProtoBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SubscribeMessageResponseProto::Traits {
  using type = SubscribeMessageResponseProto;
  static auto constexpr Create = CreateSubscribeMessageResponseProto;
};

struct SubscribeDataUpdatesRequestProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubscribeDataUpdatesRequestProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFERENCES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DataReferenceValueProto>> *references() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DataReferenceValueProto>> *>(VT_REFERENCES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_REFERENCES) &&
           verifier.VerifyVector(references()) &&
           verifier.VerifyVectorOfTables(references()) &&
           verifier.EndTable();
  }
};

struct SubscribeDataUpdatesRequestProtoBuilder {
  typedef SubscribeDataUpdatesRequestProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_references(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataReferenceValueProto>>> references) {
    fbb_.AddOffset(SubscribeDataUpdatesRequestProto::VT_REFERENCES, references);
  }
  explicit SubscribeDataUpdatesRequestProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubscribeDataUpdatesRequestProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubscribeDataUpdatesRequestProto>(end);
    fbb_.Required(o, SubscribeDataUpdatesRequestProto::VT_REFERENCES);
    return o;
  }
};

inline flatbuffers::Offset<SubscribeDataUpdatesRequestProto> CreateSubscribeDataUpdatesRequestProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataReferenceValueProto>>> references = 0) {
  SubscribeDataUpdatesRequestProtoBuilder builder_(_fbb);
  builder_.add_references(references);
  return builder_.Finish();
}

struct SubscribeDataUpdatesRequestProto::Traits {
  using type = SubscribeDataUpdatesRequestProto;
  static auto constexpr Create = CreateSubscribeDataUpdatesRequestProto;
};

inline flatbuffers::Offset<SubscribeDataUpdatesRequestProto> CreateSubscribeDataUpdatesRequestProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DataReferenceValueProto>> *references = nullptr) {
  auto references__ = references ? _fbb.CreateVector<flatbuffers::Offset<DataReferenceValueProto>>(*references) : 0;
  return CreateSubscribeDataUpdatesRequestProto(
      _fbb,
      references__);
}

struct SubscribeDataUpdatesResponseProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubscribeDataUpdatesResponseProtoBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SubscribeDataUpdatesResponseProtoBuilder {
  typedef SubscribeDataUpdatesResponseProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SubscribeDataUpdatesResponseProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubscribeDataUpdatesResponseProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubscribeDataUpdatesResponseProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubscribeDataUpdatesResponseProto> CreateSubscribeDataUpdatesResponseProto(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SubscribeDataUpdatesResponseProtoBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SubscribeDataUpdatesResponseProto::Traits {
  using type = SubscribeDataUpdatesResponseProto;
  static auto constexpr Create = CreateSubscribeDataUpdatesResponseProto;
};

struct UnsubscribeMessageRequestProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnsubscribeMessageRequestProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_SOURCE_TYPE = 6,
    VT_SOURCE = 8
  };
  uint16_t class_id() const {
    return GetField<uint16_t>(VT_CLASS_ID, 0);
  }
  WorkerReferenceUnionProto source_type() const {
    return static_cast<WorkerReferenceUnionProto>(GetField<uint8_t>(VT_SOURCE_TYPE, 0));
  }
  const void *source() const {
    return GetPointer<const void *>(VT_SOURCE);
  }
  template<typename T> const T *source_as() const;
  const DataReferenceValueProto *source_as_DataReferenceValueProto() const {
    return source_type() == WorkerReferenceUnionProto::DataReferenceValueProto ? static_cast<const DataReferenceValueProto *>(source()) : nullptr;
  }
  const ServiceReferenceValueProto *source_as_ServiceReferenceValueProto() const {
    return source_type() == WorkerReferenceUnionProto::ServiceReferenceValueProto ? static_cast<const ServiceReferenceValueProto *>(source()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CLASS_ID) &&
           VerifyField<uint8_t>(verifier, VT_SOURCE_TYPE) &&
           VerifyOffsetRequired(verifier, VT_SOURCE) &&
           VerifyWorkerReferenceUnionProto(verifier, source(), source_type()) &&
           verifier.EndTable();
  }
};

template<> inline const DataReferenceValueProto *UnsubscribeMessageRequestProto::source_as<DataReferenceValueProto>() const {
  return source_as_DataReferenceValueProto();
}

template<> inline const ServiceReferenceValueProto *UnsubscribeMessageRequestProto::source_as<ServiceReferenceValueProto>() const {
  return source_as_ServiceReferenceValueProto();
}

struct UnsubscribeMessageRequestProtoBuilder {
  typedef UnsubscribeMessageRequestProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_class_id(uint16_t class_id) {
    fbb_.AddElement<uint16_t>(UnsubscribeMessageRequestProto::VT_CLASS_ID, class_id, 0);
  }
  void add_source_type(WorkerReferenceUnionProto source_type) {
    fbb_.AddElement<uint8_t>(UnsubscribeMessageRequestProto::VT_SOURCE_TYPE, static_cast<uint8_t>(source_type), 0);
  }
  void add_source(flatbuffers::Offset<void> source) {
    fbb_.AddOffset(UnsubscribeMessageRequestProto::VT_SOURCE, source);
  }
  explicit UnsubscribeMessageRequestProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnsubscribeMessageRequestProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnsubscribeMessageRequestProto>(end);
    fbb_.Required(o, UnsubscribeMessageRequestProto::VT_SOURCE);
    return o;
  }
};

inline flatbuffers::Offset<UnsubscribeMessageRequestProto> CreateUnsubscribeMessageRequestProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    WorkerReferenceUnionProto source_type = WorkerReferenceUnionProto::NONE,
    flatbuffers::Offset<void> source = 0) {
  UnsubscribeMessageRequestProtoBuilder builder_(_fbb);
  builder_.add_source(source);
  builder_.add_class_id(class_id);
  builder_.add_source_type(source_type);
  return builder_.Finish();
}

struct UnsubscribeMessageRequestProto::Traits {
  using type = UnsubscribeMessageRequestProto;
  static auto constexpr Create = CreateUnsubscribeMessageRequestProto;
};

struct UnsubscribeMessageResponseProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnsubscribeMessageResponseProtoBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UnsubscribeMessageResponseProtoBuilder {
  typedef UnsubscribeMessageResponseProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UnsubscribeMessageResponseProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnsubscribeMessageResponseProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnsubscribeMessageResponseProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnsubscribeMessageResponseProto> CreateUnsubscribeMessageResponseProto(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UnsubscribeMessageResponseProtoBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UnsubscribeMessageResponseProto::Traits {
  using type = UnsubscribeMessageResponseProto;
  static auto constexpr Create = CreateUnsubscribeMessageResponseProto;
};

struct UnsubscribeDataUpdatesRequestProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnsubscribeDataUpdatesRequestProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFERENCES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DataReferenceValueProto>> *references() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DataReferenceValueProto>> *>(VT_REFERENCES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_REFERENCES) &&
           verifier.VerifyVector(references()) &&
           verifier.VerifyVectorOfTables(references()) &&
           verifier.EndTable();
  }
};

struct UnsubscribeDataUpdatesRequestProtoBuilder {
  typedef UnsubscribeDataUpdatesRequestProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_references(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataReferenceValueProto>>> references) {
    fbb_.AddOffset(UnsubscribeDataUpdatesRequestProto::VT_REFERENCES, references);
  }
  explicit UnsubscribeDataUpdatesRequestProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnsubscribeDataUpdatesRequestProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnsubscribeDataUpdatesRequestProto>(end);
    fbb_.Required(o, UnsubscribeDataUpdatesRequestProto::VT_REFERENCES);
    return o;
  }
};

inline flatbuffers::Offset<UnsubscribeDataUpdatesRequestProto> CreateUnsubscribeDataUpdatesRequestProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataReferenceValueProto>>> references = 0) {
  UnsubscribeDataUpdatesRequestProtoBuilder builder_(_fbb);
  builder_.add_references(references);
  return builder_.Finish();
}

struct UnsubscribeDataUpdatesRequestProto::Traits {
  using type = UnsubscribeDataUpdatesRequestProto;
  static auto constexpr Create = CreateUnsubscribeDataUpdatesRequestProto;
};

inline flatbuffers::Offset<UnsubscribeDataUpdatesRequestProto> CreateUnsubscribeDataUpdatesRequestProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DataReferenceValueProto>> *references = nullptr) {
  auto references__ = references ? _fbb.CreateVector<flatbuffers::Offset<DataReferenceValueProto>>(*references) : 0;
  return CreateUnsubscribeDataUpdatesRequestProto(
      _fbb,
      references__);
}

struct UnsubscribeDataUpdatesResponseProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnsubscribeDataUpdatesResponseProtoBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UnsubscribeDataUpdatesResponseProtoBuilder {
  typedef UnsubscribeDataUpdatesResponseProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UnsubscribeDataUpdatesResponseProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnsubscribeDataUpdatesResponseProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnsubscribeDataUpdatesResponseProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnsubscribeDataUpdatesResponseProto> CreateUnsubscribeDataUpdatesResponseProto(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UnsubscribeDataUpdatesResponseProtoBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UnsubscribeDataUpdatesResponseProto::Traits {
  using type = UnsubscribeDataUpdatesResponseProto;
  static auto constexpr Create = CreateUnsubscribeDataUpdatesResponseProto;
};

struct UserRequestProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UserRequestProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL_VERSION = 4,
    VT_LOG_CONTEXT = 6,
    VT_WORKER_ID = 8,
    VT_WORKER_VERSION = 10,
    VT_REQUEST_TYPE = 12,
    VT_REQUEST = 14
  };
  uint8_t protocol_version() const {
    return GetField<uint8_t>(VT_PROTOCOL_VERSION, 0);
  }
  const flatbuffers::String *log_context() const {
    return GetPointer<const flatbuffers::String *>(VT_LOG_CONTEXT);
  }
  uint64_t worker_id() const {
    return GetField<uint64_t>(VT_WORKER_ID, 0);
  }
  uint64_t worker_version() const {
    return GetField<uint64_t>(VT_WORKER_VERSION, 0);
  }
  UserRequestUnionProto request_type() const {
    return static_cast<UserRequestUnionProto>(GetField<uint8_t>(VT_REQUEST_TYPE, 0));
  }
  const void *request() const {
    return GetPointer<const void *>(VT_REQUEST);
  }
  template<typename T> const T *request_as() const;
  const CallServiceMethodRequestProto *request_as_CallServiceMethodRequestProto() const {
    return request_type() == UserRequestUnionProto::CallServiceMethodRequestProto ? static_cast<const CallServiceMethodRequestProto *>(request()) : nullptr;
  }
  const GetDataRequestProto *request_as_GetDataRequestProto() const {
    return request_type() == UserRequestUnionProto::GetDataRequestProto ? static_cast<const GetDataRequestProto *>(request()) : nullptr;
  }
  const SaveDataRequestProto *request_as_SaveDataRequestProto() const {
    return request_type() == UserRequestUnionProto::SaveDataRequestProto ? static_cast<const SaveDataRequestProto *>(request()) : nullptr;
  }
  const SubscribeMessageRequestProto *request_as_SubscribeMessageRequestProto() const {
    return request_type() == UserRequestUnionProto::SubscribeMessageRequestProto ? static_cast<const SubscribeMessageRequestProto *>(request()) : nullptr;
  }
  const UnsubscribeMessageRequestProto *request_as_UnsubscribeMessageRequestProto() const {
    return request_type() == UserRequestUnionProto::UnsubscribeMessageRequestProto ? static_cast<const UnsubscribeMessageRequestProto *>(request()) : nullptr;
  }
  const SubscribeDataUpdatesRequestProto *request_as_SubscribeDataUpdatesRequestProto() const {
    return request_type() == UserRequestUnionProto::SubscribeDataUpdatesRequestProto ? static_cast<const SubscribeDataUpdatesRequestProto *>(request()) : nullptr;
  }
  const UnsubscribeDataUpdatesRequestProto *request_as_UnsubscribeDataUpdatesRequestProto() const {
    return request_type() == UserRequestUnionProto::UnsubscribeDataUpdatesRequestProto ? static_cast<const UnsubscribeDataUpdatesRequestProto *>(request()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PROTOCOL_VERSION) &&
           VerifyOffsetRequired(verifier, VT_LOG_CONTEXT) &&
           verifier.VerifyString(log_context()) &&
           VerifyField<uint64_t>(verifier, VT_WORKER_ID) &&
           VerifyField<uint64_t>(verifier, VT_WORKER_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_REQUEST_TYPE) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           VerifyUserRequestUnionProto(verifier, request(), request_type()) &&
           verifier.EndTable();
  }
};

template<> inline const CallServiceMethodRequestProto *UserRequestProto::request_as<CallServiceMethodRequestProto>() const {
  return request_as_CallServiceMethodRequestProto();
}

template<> inline const GetDataRequestProto *UserRequestProto::request_as<GetDataRequestProto>() const {
  return request_as_GetDataRequestProto();
}

template<> inline const SaveDataRequestProto *UserRequestProto::request_as<SaveDataRequestProto>() const {
  return request_as_SaveDataRequestProto();
}

template<> inline const SubscribeMessageRequestProto *UserRequestProto::request_as<SubscribeMessageRequestProto>() const {
  return request_as_SubscribeMessageRequestProto();
}

template<> inline const UnsubscribeMessageRequestProto *UserRequestProto::request_as<UnsubscribeMessageRequestProto>() const {
  return request_as_UnsubscribeMessageRequestProto();
}

template<> inline const SubscribeDataUpdatesRequestProto *UserRequestProto::request_as<SubscribeDataUpdatesRequestProto>() const {
  return request_as_SubscribeDataUpdatesRequestProto();
}

template<> inline const UnsubscribeDataUpdatesRequestProto *UserRequestProto::request_as<UnsubscribeDataUpdatesRequestProto>() const {
  return request_as_UnsubscribeDataUpdatesRequestProto();
}

struct UserRequestProtoBuilder {
  typedef UserRequestProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_protocol_version(uint8_t protocol_version) {
    fbb_.AddElement<uint8_t>(UserRequestProto::VT_PROTOCOL_VERSION, protocol_version, 0);
  }
  void add_log_context(flatbuffers::Offset<flatbuffers::String> log_context) {
    fbb_.AddOffset(UserRequestProto::VT_LOG_CONTEXT, log_context);
  }
  void add_worker_id(uint64_t worker_id) {
    fbb_.AddElement<uint64_t>(UserRequestProto::VT_WORKER_ID, worker_id, 0);
  }
  void add_worker_version(uint64_t worker_version) {
    fbb_.AddElement<uint64_t>(UserRequestProto::VT_WORKER_VERSION, worker_version, 0);
  }
  void add_request_type(UserRequestUnionProto request_type) {
    fbb_.AddElement<uint8_t>(UserRequestProto::VT_REQUEST_TYPE, static_cast<uint8_t>(request_type), 0);
  }
  void add_request(flatbuffers::Offset<void> request) {
    fbb_.AddOffset(UserRequestProto::VT_REQUEST, request);
  }
  explicit UserRequestProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UserRequestProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserRequestProto>(end);
    fbb_.Required(o, UserRequestProto::VT_LOG_CONTEXT);
    return o;
  }
};

inline flatbuffers::Offset<UserRequestProto> CreateUserRequestProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t protocol_version = 0,
    flatbuffers::Offset<flatbuffers::String> log_context = 0,
    uint64_t worker_id = 0,
    uint64_t worker_version = 0,
    UserRequestUnionProto request_type = UserRequestUnionProto::NONE,
    flatbuffers::Offset<void> request = 0) {
  UserRequestProtoBuilder builder_(_fbb);
  builder_.add_worker_version(worker_version);
  builder_.add_worker_id(worker_id);
  builder_.add_request(request);
  builder_.add_log_context(log_context);
  builder_.add_request_type(request_type);
  builder_.add_protocol_version(protocol_version);
  return builder_.Finish();
}

struct UserRequestProto::Traits {
  using type = UserRequestProto;
  static auto constexpr Create = CreateUserRequestProto;
};

inline flatbuffers::Offset<UserRequestProto> CreateUserRequestProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t protocol_version = 0,
    const char *log_context = nullptr,
    uint64_t worker_id = 0,
    uint64_t worker_version = 0,
    UserRequestUnionProto request_type = UserRequestUnionProto::NONE,
    flatbuffers::Offset<void> request = 0) {
  auto log_context__ = log_context ? _fbb.CreateString(log_context) : 0;
  return CreateUserRequestProto(
      _fbb,
      protocol_version,
      log_context__,
      worker_id,
      worker_version,
      request_type,
      request);
}

inline bool VerifyUserMessageUnionProto(flatbuffers::Verifier &verifier, const void *obj, UserMessageUnionProto type) {
  switch (type) {
    case UserMessageUnionProto::NONE: {
      return true;
    }
    case UserMessageUnionProto::DataUpdateMessageProto: {
      auto ptr = reinterpret_cast<const DataUpdateMessageProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserMessageUnionProto::MessageMessageProto: {
      auto ptr = reinterpret_cast<const MessageMessageProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyUserMessageUnionProtoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUserMessageUnionProto(
        verifier,  values->Get(i), types->GetEnum<UserMessageUnionProto>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyUserResponseUnionProto(flatbuffers::Verifier &verifier, const void *obj, UserResponseUnionProto type) {
  switch (type) {
    case UserResponseUnionProto::NONE: {
      return true;
    }
    case UserResponseUnionProto::ErrorCodeResponseProto: {
      auto ptr = reinterpret_cast<const ErrorCodeResponseProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserResponseUnionProto::ExceptionResponseProto: {
      auto ptr = reinterpret_cast<const ExceptionResponseProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserResponseUnionProto::CallServiceMethodResponseProto: {
      auto ptr = reinterpret_cast<const CallServiceMethodResponseProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserResponseUnionProto::GetDataResponseProto: {
      auto ptr = reinterpret_cast<const GetDataResponseProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserResponseUnionProto::SaveDataResponseProto: {
      auto ptr = reinterpret_cast<const SaveDataResponseProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserResponseUnionProto::SubscribeMessageResponseProto: {
      auto ptr = reinterpret_cast<const SubscribeMessageResponseProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserResponseUnionProto::UnsubscribeMessageResponseProto: {
      auto ptr = reinterpret_cast<const UnsubscribeMessageResponseProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserResponseUnionProto::SubscribeDataUpdatesResponseProto: {
      auto ptr = reinterpret_cast<const SubscribeDataUpdatesResponseProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserResponseUnionProto::UnsubscribeDataUpdatesResponseProto: {
      auto ptr = reinterpret_cast<const UnsubscribeDataUpdatesResponseProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyUserResponseUnionProtoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUserResponseUnionProto(
        verifier,  values->Get(i), types->GetEnum<UserResponseUnionProto>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyUserRequestUnionProto(flatbuffers::Verifier &verifier, const void *obj, UserRequestUnionProto type) {
  switch (type) {
    case UserRequestUnionProto::NONE: {
      return true;
    }
    case UserRequestUnionProto::CallServiceMethodRequestProto: {
      auto ptr = reinterpret_cast<const CallServiceMethodRequestProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserRequestUnionProto::GetDataRequestProto: {
      auto ptr = reinterpret_cast<const GetDataRequestProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserRequestUnionProto::SaveDataRequestProto: {
      auto ptr = reinterpret_cast<const SaveDataRequestProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserRequestUnionProto::SubscribeMessageRequestProto: {
      auto ptr = reinterpret_cast<const SubscribeMessageRequestProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserRequestUnionProto::UnsubscribeMessageRequestProto: {
      auto ptr = reinterpret_cast<const UnsubscribeMessageRequestProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserRequestUnionProto::SubscribeDataUpdatesRequestProto: {
      auto ptr = reinterpret_cast<const SubscribeDataUpdatesRequestProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserRequestUnionProto::UnsubscribeDataUpdatesRequestProto: {
      auto ptr = reinterpret_cast<const UnsubscribeDataUpdatesRequestProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyUserRequestUnionProtoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUserRequestUnionProto(
        verifier,  values->Get(i), types->GetEnum<UserRequestUnionProto>(i))) {
      return false;
    }
  }
  return true;
}

#endif  // FLATBUFFERS_GENERATED_INTERFACE_H_
