// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODEL_H_
#define FLATBUFFERS_GENERATED_MODEL_H_

#include "flatbuffers/flatbuffers.h"

struct ConsoleLogMessageProto;
struct ConsoleLogMessageProtoBuilder;

struct ConsoleLogProto;
struct ConsoleLogProtoBuilder;

struct ConsoleLogBytesProto;
struct ConsoleLogBytesProtoBuilder;

struct NestedPropertyProto;
struct NestedPropertyProtoBuilder;

struct PropertyProto;
struct PropertyProtoBuilder;

struct ValueProto;
struct ValueProtoBuilder;

struct UndefinedValueProto;
struct UndefinedValueProtoBuilder;

struct NullValueProto;
struct NullValueProtoBuilder;

struct BooleanValueProto;
struct BooleanValueProtoBuilder;

struct StringValueProto;
struct StringValueProtoBuilder;

struct NumberValueProto;
struct NumberValueProtoBuilder;

struct ObjectValueProto;
struct ObjectValueProtoBuilder;

struct ArrayItemValueProto;
struct ArrayItemValueProtoBuilder;

struct ArrayValueProto;
struct ArrayValueProtoBuilder;

struct DataReferenceValueProto;
struct DataReferenceValueProtoBuilder;

struct ServiceReferenceValueProto;
struct ServiceReferenceValueProtoBuilder;

struct MapValueItemProto;
struct MapValueItemProtoBuilder;

struct MapValueProto;
struct MapValueProtoBuilder;

struct SetValueProto;
struct SetValueProtoBuilder;

struct DateValueProto;
struct DateValueProtoBuilder;

struct MessageProto;
struct MessageProtoBuilder;

struct MessageBytesProto;
struct MessageBytesProtoBuilder;

struct DataDeltaBytesProto;
struct DataDeltaBytesProtoBuilder;

struct InboundDataDeltaProto;
struct InboundDataDeltaProtoBuilder;

struct DataDeltaProto;
struct DataDeltaProtoBuilder;

struct DataHandleProto;
struct DataHandleProtoBuilder;

struct DataProto;
struct DataProtoBuilder;

struct NestedDataProto;
struct NestedDataProtoBuilder;

enum class ValueUnionProto : uint8_t {
  NONE = 0,
  UndefinedValueProto = 1,
  NullValueProto = 2,
  BooleanValueProto = 3,
  StringValueProto = 4,
  NumberValueProto = 5,
  ObjectValueProto = 6,
  ArrayValueProto = 7,
  DataReferenceValueProto = 8,
  ServiceReferenceValueProto = 9,
  MapValueProto = 10,
  SetValueProto = 11,
  DateValueProto = 12,
  MIN = NONE,
  MAX = DateValueProto
};

inline const ValueUnionProto (&EnumValuesValueUnionProto())[13] {
  static const ValueUnionProto values[] = {
    ValueUnionProto::NONE,
    ValueUnionProto::UndefinedValueProto,
    ValueUnionProto::NullValueProto,
    ValueUnionProto::BooleanValueProto,
    ValueUnionProto::StringValueProto,
    ValueUnionProto::NumberValueProto,
    ValueUnionProto::ObjectValueProto,
    ValueUnionProto::ArrayValueProto,
    ValueUnionProto::DataReferenceValueProto,
    ValueUnionProto::ServiceReferenceValueProto,
    ValueUnionProto::MapValueProto,
    ValueUnionProto::SetValueProto,
    ValueUnionProto::DateValueProto
  };
  return values;
}

inline const char * const *EnumNamesValueUnionProto() {
  static const char * const names[14] = {
    "NONE",
    "UndefinedValueProto",
    "NullValueProto",
    "BooleanValueProto",
    "StringValueProto",
    "NumberValueProto",
    "ObjectValueProto",
    "ArrayValueProto",
    "DataReferenceValueProto",
    "ServiceReferenceValueProto",
    "MapValueProto",
    "SetValueProto",
    "DateValueProto",
    nullptr
  };
  return names;
}

inline const char *EnumNameValueUnionProto(ValueUnionProto e) {
  if (flatbuffers::IsOutRange(e, ValueUnionProto::NONE, ValueUnionProto::DateValueProto)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValueUnionProto()[index];
}

template<typename T> struct ValueUnionProtoTraits {
  static const ValueUnionProto enum_value = ValueUnionProto::NONE;
};

template<> struct ValueUnionProtoTraits<UndefinedValueProto> {
  static const ValueUnionProto enum_value = ValueUnionProto::UndefinedValueProto;
};

template<> struct ValueUnionProtoTraits<NullValueProto> {
  static const ValueUnionProto enum_value = ValueUnionProto::NullValueProto;
};

template<> struct ValueUnionProtoTraits<BooleanValueProto> {
  static const ValueUnionProto enum_value = ValueUnionProto::BooleanValueProto;
};

template<> struct ValueUnionProtoTraits<StringValueProto> {
  static const ValueUnionProto enum_value = ValueUnionProto::StringValueProto;
};

template<> struct ValueUnionProtoTraits<NumberValueProto> {
  static const ValueUnionProto enum_value = ValueUnionProto::NumberValueProto;
};

template<> struct ValueUnionProtoTraits<ObjectValueProto> {
  static const ValueUnionProto enum_value = ValueUnionProto::ObjectValueProto;
};

template<> struct ValueUnionProtoTraits<ArrayValueProto> {
  static const ValueUnionProto enum_value = ValueUnionProto::ArrayValueProto;
};

template<> struct ValueUnionProtoTraits<DataReferenceValueProto> {
  static const ValueUnionProto enum_value = ValueUnionProto::DataReferenceValueProto;
};

template<> struct ValueUnionProtoTraits<ServiceReferenceValueProto> {
  static const ValueUnionProto enum_value = ValueUnionProto::ServiceReferenceValueProto;
};

template<> struct ValueUnionProtoTraits<MapValueProto> {
  static const ValueUnionProto enum_value = ValueUnionProto::MapValueProto;
};

template<> struct ValueUnionProtoTraits<SetValueProto> {
  static const ValueUnionProto enum_value = ValueUnionProto::SetValueProto;
};

template<> struct ValueUnionProtoTraits<DateValueProto> {
  static const ValueUnionProto enum_value = ValueUnionProto::DateValueProto;
};

bool VerifyValueUnionProto(flatbuffers::Verifier &verifier, const void *obj, ValueUnionProto type);
bool VerifyValueUnionProtoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class WorkerReferenceUnionProto : uint8_t {
  NONE = 0,
  DataReferenceValueProto = 1,
  ServiceReferenceValueProto = 2,
  MIN = NONE,
  MAX = ServiceReferenceValueProto
};

inline const WorkerReferenceUnionProto (&EnumValuesWorkerReferenceUnionProto())[3] {
  static const WorkerReferenceUnionProto values[] = {
    WorkerReferenceUnionProto::NONE,
    WorkerReferenceUnionProto::DataReferenceValueProto,
    WorkerReferenceUnionProto::ServiceReferenceValueProto
  };
  return values;
}

inline const char * const *EnumNamesWorkerReferenceUnionProto() {
  static const char * const names[4] = {
    "NONE",
    "DataReferenceValueProto",
    "ServiceReferenceValueProto",
    nullptr
  };
  return names;
}

inline const char *EnumNameWorkerReferenceUnionProto(WorkerReferenceUnionProto e) {
  if (flatbuffers::IsOutRange(e, WorkerReferenceUnionProto::NONE, WorkerReferenceUnionProto::ServiceReferenceValueProto)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWorkerReferenceUnionProto()[index];
}

template<typename T> struct WorkerReferenceUnionProtoTraits {
  static const WorkerReferenceUnionProto enum_value = WorkerReferenceUnionProto::NONE;
};

template<> struct WorkerReferenceUnionProtoTraits<DataReferenceValueProto> {
  static const WorkerReferenceUnionProto enum_value = WorkerReferenceUnionProto::DataReferenceValueProto;
};

template<> struct WorkerReferenceUnionProtoTraits<ServiceReferenceValueProto> {
  static const WorkerReferenceUnionProto enum_value = WorkerReferenceUnionProto::ServiceReferenceValueProto;
};

bool VerifyWorkerReferenceUnionProto(flatbuffers::Verifier &verifier, const void *obj, WorkerReferenceUnionProto type);
bool VerifyWorkerReferenceUnionProtoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct ConsoleLogMessageProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConsoleLogMessageProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4,
    VT_ERROR = 6
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool error() const {
    return GetField<uint8_t>(VT_ERROR, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyField<uint8_t>(verifier, VT_ERROR) &&
           verifier.EndTable();
  }
};

struct ConsoleLogMessageProtoBuilder {
  typedef ConsoleLogMessageProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(ConsoleLogMessageProto::VT_MESSAGE, message);
  }
  void add_error(bool error) {
    fbb_.AddElement<uint8_t>(ConsoleLogMessageProto::VT_ERROR, static_cast<uint8_t>(error), 0);
  }
  explicit ConsoleLogMessageProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConsoleLogMessageProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConsoleLogMessageProto>(end);
    fbb_.Required(o, ConsoleLogMessageProto::VT_MESSAGE);
    return o;
  }
};

inline flatbuffers::Offset<ConsoleLogMessageProto> CreateConsoleLogMessageProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    bool error = false) {
  ConsoleLogMessageProtoBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_error(error);
  return builder_.Finish();
}

struct ConsoleLogMessageProto::Traits {
  using type = ConsoleLogMessageProto;
  static auto constexpr Create = CreateConsoleLogMessageProto;
};

inline flatbuffers::Offset<ConsoleLogMessageProto> CreateConsoleLogMessageProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr,
    bool error = false) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return CreateConsoleLogMessageProto(
      _fbb,
      message__,
      error);
}

struct ConsoleLogProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConsoleLogProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ConsoleLogMessageProto>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ConsoleLogMessageProto>> *>(VT_MESSAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           verifier.EndTable();
  }
};

struct ConsoleLogProtoBuilder {
  typedef ConsoleLogProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ConsoleLogMessageProto>>> messages) {
    fbb_.AddOffset(ConsoleLogProto::VT_MESSAGES, messages);
  }
  explicit ConsoleLogProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConsoleLogProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConsoleLogProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConsoleLogProto> CreateConsoleLogProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ConsoleLogMessageProto>>> messages = 0) {
  ConsoleLogProtoBuilder builder_(_fbb);
  builder_.add_messages(messages);
  return builder_.Finish();
}

struct ConsoleLogProto::Traits {
  using type = ConsoleLogProto;
  static auto constexpr Create = CreateConsoleLogProto;
};

inline flatbuffers::Offset<ConsoleLogProto> CreateConsoleLogProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ConsoleLogMessageProto>> *messages = nullptr) {
  auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<ConsoleLogMessageProto>>(*messages) : 0;
  return CreateConsoleLogProto(
      _fbb,
      messages__);
}

struct ConsoleLogBytesProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConsoleLogBytesProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BYTES = 4
  };
  const flatbuffers::Vector<uint8_t> *bytes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BYTES);
  }
  const ConsoleLogProto *bytes_nested_root() const {
    return flatbuffers::GetRoot<ConsoleLogProto>(bytes()->Data());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BYTES) &&
           verifier.VerifyVector(bytes()) &&
           verifier.EndTable();
  }
};

struct ConsoleLogBytesProtoBuilder {
  typedef ConsoleLogBytesProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bytes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes) {
    fbb_.AddOffset(ConsoleLogBytesProto::VT_BYTES, bytes);
  }
  explicit ConsoleLogBytesProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConsoleLogBytesProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConsoleLogBytesProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConsoleLogBytesProto> CreateConsoleLogBytesProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes = 0) {
  ConsoleLogBytesProtoBuilder builder_(_fbb);
  builder_.add_bytes(bytes);
  return builder_.Finish();
}

struct ConsoleLogBytesProto::Traits {
  using type = ConsoleLogBytesProto;
  static auto constexpr Create = CreateConsoleLogBytesProto;
};

inline flatbuffers::Offset<ConsoleLogBytesProto> CreateConsoleLogBytesProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *bytes = nullptr) {
  auto bytes__ = bytes ? _fbb.CreateVector<uint8_t>(*bytes) : 0;
  return CreateConsoleLogBytesProto(
      _fbb,
      bytes__);
}

struct NestedPropertyProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NestedPropertyProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE_BYTES = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *value_bytes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE_BYTES);
  }
  const ValueProto *value_bytes_nested_root() const {
    return flatbuffers::GetRoot<ValueProto>(value_bytes()->Data());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE_BYTES) &&
           verifier.VerifyVector(value_bytes()) &&
           verifier.EndTable();
  }
};

struct NestedPropertyProtoBuilder {
  typedef NestedPropertyProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NestedPropertyProto::VT_NAME, name);
  }
  void add_value_bytes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value_bytes) {
    fbb_.AddOffset(NestedPropertyProto::VT_VALUE_BYTES, value_bytes);
  }
  explicit NestedPropertyProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NestedPropertyProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NestedPropertyProto>(end);
    fbb_.Required(o, NestedPropertyProto::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<NestedPropertyProto> CreateNestedPropertyProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value_bytes = 0) {
  NestedPropertyProtoBuilder builder_(_fbb);
  builder_.add_value_bytes(value_bytes);
  builder_.add_name(name);
  return builder_.Finish();
}

struct NestedPropertyProto::Traits {
  using type = NestedPropertyProto;
  static auto constexpr Create = CreateNestedPropertyProto;
};

inline flatbuffers::Offset<NestedPropertyProto> CreateNestedPropertyProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint8_t> *value_bytes = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value_bytes__ = value_bytes ? _fbb.CreateVector<uint8_t>(*value_bytes) : 0;
  return CreateNestedPropertyProto(
      _fbb,
      name__,
      value_bytes__);
}

struct PropertyProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PropertyProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const ValueProto *value() const {
    return GetPointer<const ValueProto *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct PropertyProtoBuilder {
  typedef PropertyProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PropertyProto::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<ValueProto> value) {
    fbb_.AddOffset(PropertyProto::VT_VALUE, value);
  }
  explicit PropertyProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PropertyProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PropertyProto>(end);
    fbb_.Required(o, PropertyProto::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<PropertyProto> CreatePropertyProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<ValueProto> value = 0) {
  PropertyProtoBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

struct PropertyProto::Traits {
  using type = PropertyProto;
  static auto constexpr Create = CreatePropertyProto;
};

inline flatbuffers::Offset<PropertyProto> CreatePropertyProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<ValueProto> value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreatePropertyProto(
      _fbb,
      name__,
      value);
}

struct ValueProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ValueProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  ValueUnionProto value_type() const {
    return static_cast<ValueUnionProto>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const UndefinedValueProto *value_as_UndefinedValueProto() const {
    return value_type() == ValueUnionProto::UndefinedValueProto ? static_cast<const UndefinedValueProto *>(value()) : nullptr;
  }
  const NullValueProto *value_as_NullValueProto() const {
    return value_type() == ValueUnionProto::NullValueProto ? static_cast<const NullValueProto *>(value()) : nullptr;
  }
  const BooleanValueProto *value_as_BooleanValueProto() const {
    return value_type() == ValueUnionProto::BooleanValueProto ? static_cast<const BooleanValueProto *>(value()) : nullptr;
  }
  const StringValueProto *value_as_StringValueProto() const {
    return value_type() == ValueUnionProto::StringValueProto ? static_cast<const StringValueProto *>(value()) : nullptr;
  }
  const NumberValueProto *value_as_NumberValueProto() const {
    return value_type() == ValueUnionProto::NumberValueProto ? static_cast<const NumberValueProto *>(value()) : nullptr;
  }
  const ObjectValueProto *value_as_ObjectValueProto() const {
    return value_type() == ValueUnionProto::ObjectValueProto ? static_cast<const ObjectValueProto *>(value()) : nullptr;
  }
  const ArrayValueProto *value_as_ArrayValueProto() const {
    return value_type() == ValueUnionProto::ArrayValueProto ? static_cast<const ArrayValueProto *>(value()) : nullptr;
  }
  const DataReferenceValueProto *value_as_DataReferenceValueProto() const {
    return value_type() == ValueUnionProto::DataReferenceValueProto ? static_cast<const DataReferenceValueProto *>(value()) : nullptr;
  }
  const ServiceReferenceValueProto *value_as_ServiceReferenceValueProto() const {
    return value_type() == ValueUnionProto::ServiceReferenceValueProto ? static_cast<const ServiceReferenceValueProto *>(value()) : nullptr;
  }
  const MapValueProto *value_as_MapValueProto() const {
    return value_type() == ValueUnionProto::MapValueProto ? static_cast<const MapValueProto *>(value()) : nullptr;
  }
  const SetValueProto *value_as_SetValueProto() const {
    return value_type() == ValueUnionProto::SetValueProto ? static_cast<const SetValueProto *>(value()) : nullptr;
  }
  const DateValueProto *value_as_DateValueProto() const {
    return value_type() == ValueUnionProto::DateValueProto ? static_cast<const DateValueProto *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValueUnionProto(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const UndefinedValueProto *ValueProto::value_as<UndefinedValueProto>() const {
  return value_as_UndefinedValueProto();
}

template<> inline const NullValueProto *ValueProto::value_as<NullValueProto>() const {
  return value_as_NullValueProto();
}

template<> inline const BooleanValueProto *ValueProto::value_as<BooleanValueProto>() const {
  return value_as_BooleanValueProto();
}

template<> inline const StringValueProto *ValueProto::value_as<StringValueProto>() const {
  return value_as_StringValueProto();
}

template<> inline const NumberValueProto *ValueProto::value_as<NumberValueProto>() const {
  return value_as_NumberValueProto();
}

template<> inline const ObjectValueProto *ValueProto::value_as<ObjectValueProto>() const {
  return value_as_ObjectValueProto();
}

template<> inline const ArrayValueProto *ValueProto::value_as<ArrayValueProto>() const {
  return value_as_ArrayValueProto();
}

template<> inline const DataReferenceValueProto *ValueProto::value_as<DataReferenceValueProto>() const {
  return value_as_DataReferenceValueProto();
}

template<> inline const ServiceReferenceValueProto *ValueProto::value_as<ServiceReferenceValueProto>() const {
  return value_as_ServiceReferenceValueProto();
}

template<> inline const MapValueProto *ValueProto::value_as<MapValueProto>() const {
  return value_as_MapValueProto();
}

template<> inline const SetValueProto *ValueProto::value_as<SetValueProto>() const {
  return value_as_SetValueProto();
}

template<> inline const DateValueProto *ValueProto::value_as<DateValueProto>() const {
  return value_as_DateValueProto();
}

struct ValueProtoBuilder {
  typedef ValueProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(ValueUnionProto value_type) {
    fbb_.AddElement<uint8_t>(ValueProto::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(ValueProto::VT_VALUE, value);
  }
  explicit ValueProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ValueProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ValueProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<ValueProto> CreateValueProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    ValueUnionProto value_type = ValueUnionProto::NONE,
    flatbuffers::Offset<void> value = 0) {
  ValueProtoBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct ValueProto::Traits {
  using type = ValueProto;
  static auto constexpr Create = CreateValueProto;
};

struct UndefinedValueProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UndefinedValueProtoBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UndefinedValueProtoBuilder {
  typedef UndefinedValueProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UndefinedValueProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UndefinedValueProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UndefinedValueProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<UndefinedValueProto> CreateUndefinedValueProto(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UndefinedValueProtoBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UndefinedValueProto::Traits {
  using type = UndefinedValueProto;
  static auto constexpr Create = CreateUndefinedValueProto;
};

struct NullValueProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NullValueProtoBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NullValueProtoBuilder {
  typedef NullValueProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NullValueProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NullValueProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NullValueProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<NullValueProto> CreateNullValueProto(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NullValueProtoBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NullValueProto::Traits {
  using type = NullValueProto;
  static auto constexpr Create = CreateNullValueProto;
};

struct BooleanValueProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BooleanValueProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct BooleanValueProtoBuilder {
  typedef BooleanValueProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(BooleanValueProto::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit BooleanValueProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BooleanValueProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BooleanValueProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<BooleanValueProto> CreateBooleanValueProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  BooleanValueProtoBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct BooleanValueProto::Traits {
  using type = BooleanValueProto;
  static auto constexpr Create = CreateBooleanValueProto;
};

struct StringValueProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringValueProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringValueProtoBuilder {
  typedef StringValueProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(StringValueProto::VT_VALUE, value);
  }
  explicit StringValueProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StringValueProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringValueProto>(end);
    fbb_.Required(o, StringValueProto::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<StringValueProto> CreateStringValueProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringValueProtoBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct StringValueProto::Traits {
  using type = StringValueProto;
  static auto constexpr Create = CreateStringValueProto;
};

inline flatbuffers::Offset<StringValueProto> CreateStringValueProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return CreateStringValueProto(
      _fbb,
      value__);
}

struct NumberValueProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NumberValueProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct NumberValueProtoBuilder {
  typedef NumberValueProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(NumberValueProto::VT_VALUE, value, 0.0);
  }
  explicit NumberValueProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NumberValueProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NumberValueProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<NumberValueProto> CreateNumberValueProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  NumberValueProtoBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NumberValueProto::Traits {
  using type = NumberValueProto;
  static auto constexpr Create = CreateNumberValueProto;
};

struct ObjectValueProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectValueProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROPERTIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<PropertyProto>> *properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PropertyProto>> *>(VT_PROPERTIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           verifier.EndTable();
  }
};

struct ObjectValueProtoBuilder {
  typedef ObjectValueProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PropertyProto>>> properties) {
    fbb_.AddOffset(ObjectValueProto::VT_PROPERTIES, properties);
  }
  explicit ObjectValueProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectValueProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectValueProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectValueProto> CreateObjectValueProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PropertyProto>>> properties = 0) {
  ObjectValueProtoBuilder builder_(_fbb);
  builder_.add_properties(properties);
  return builder_.Finish();
}

struct ObjectValueProto::Traits {
  using type = ObjectValueProto;
  static auto constexpr Create = CreateObjectValueProto;
};

inline flatbuffers::Offset<ObjectValueProto> CreateObjectValueProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<PropertyProto>> *properties = nullptr) {
  auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<PropertyProto>>(*properties) : 0;
  return CreateObjectValueProto(
      _fbb,
      properties__);
}

struct ArrayItemValueProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayItemValueProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_VALUE = 6
  };
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  const ValueProto *value() const {
    return GetPointer<const ValueProto *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INDEX) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct ArrayItemValueProtoBuilder {
  typedef ArrayItemValueProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(ArrayItemValueProto::VT_INDEX, index, 0);
  }
  void add_value(flatbuffers::Offset<ValueProto> value) {
    fbb_.AddOffset(ArrayItemValueProto::VT_VALUE, value);
  }
  explicit ArrayItemValueProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArrayItemValueProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArrayItemValueProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArrayItemValueProto> CreateArrayItemValueProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t index = 0,
    flatbuffers::Offset<ValueProto> value = 0) {
  ArrayItemValueProtoBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_index(index);
  return builder_.Finish();
}

struct ArrayItemValueProto::Traits {
  using type = ArrayItemValueProto;
  static auto constexpr Create = CreateArrayItemValueProto;
};

struct ArrayValueProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArrayValueProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ArrayItemValueProto>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ArrayItemValueProto>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct ArrayValueProtoBuilder {
  typedef ArrayValueProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArrayItemValueProto>>> items) {
    fbb_.AddOffset(ArrayValueProto::VT_ITEMS, items);
  }
  explicit ArrayValueProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArrayValueProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArrayValueProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArrayValueProto> CreateArrayValueProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArrayItemValueProto>>> items = 0) {
  ArrayValueProtoBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

struct ArrayValueProto::Traits {
  using type = ArrayValueProto;
  static auto constexpr Create = CreateArrayValueProto;
};

inline flatbuffers::Offset<ArrayValueProto> CreateArrayValueProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ArrayItemValueProto>> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<flatbuffers::Offset<ArrayItemValueProto>>(*items) : 0;
  return CreateArrayValueProto(
      _fbb,
      items__);
}

struct DataReferenceValueProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataReferenceValueProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_PRIMARY_KEY = 6
  };
  uint16_t class_id() const {
    return GetField<uint16_t>(VT_CLASS_ID, 0);
  }
  const flatbuffers::String *primary_key() const {
    return GetPointer<const flatbuffers::String *>(VT_PRIMARY_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CLASS_ID) &&
           VerifyOffsetRequired(verifier, VT_PRIMARY_KEY) &&
           verifier.VerifyString(primary_key()) &&
           verifier.EndTable();
  }
};

struct DataReferenceValueProtoBuilder {
  typedef DataReferenceValueProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_class_id(uint16_t class_id) {
    fbb_.AddElement<uint16_t>(DataReferenceValueProto::VT_CLASS_ID, class_id, 0);
  }
  void add_primary_key(flatbuffers::Offset<flatbuffers::String> primary_key) {
    fbb_.AddOffset(DataReferenceValueProto::VT_PRIMARY_KEY, primary_key);
  }
  explicit DataReferenceValueProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataReferenceValueProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataReferenceValueProto>(end);
    fbb_.Required(o, DataReferenceValueProto::VT_PRIMARY_KEY);
    return o;
  }
};

inline flatbuffers::Offset<DataReferenceValueProto> CreateDataReferenceValueProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    flatbuffers::Offset<flatbuffers::String> primary_key = 0) {
  DataReferenceValueProtoBuilder builder_(_fbb);
  builder_.add_primary_key(primary_key);
  builder_.add_class_id(class_id);
  return builder_.Finish();
}

struct DataReferenceValueProto::Traits {
  using type = DataReferenceValueProto;
  static auto constexpr Create = CreateDataReferenceValueProto;
};

inline flatbuffers::Offset<DataReferenceValueProto> CreateDataReferenceValueProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    const char *primary_key = nullptr) {
  auto primary_key__ = primary_key ? _fbb.CreateString(primary_key) : 0;
  return CreateDataReferenceValueProto(
      _fbb,
      class_id,
      primary_key__);
}

struct ServiceReferenceValueProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServiceReferenceValueProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_PRIMARY_KEY = 6
  };
  uint16_t class_id() const {
    return GetField<uint16_t>(VT_CLASS_ID, 0);
  }
  const flatbuffers::String *primary_key() const {
    return GetPointer<const flatbuffers::String *>(VT_PRIMARY_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CLASS_ID) &&
           VerifyOffsetRequired(verifier, VT_PRIMARY_KEY) &&
           verifier.VerifyString(primary_key()) &&
           verifier.EndTable();
  }
};

struct ServiceReferenceValueProtoBuilder {
  typedef ServiceReferenceValueProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_class_id(uint16_t class_id) {
    fbb_.AddElement<uint16_t>(ServiceReferenceValueProto::VT_CLASS_ID, class_id, 0);
  }
  void add_primary_key(flatbuffers::Offset<flatbuffers::String> primary_key) {
    fbb_.AddOffset(ServiceReferenceValueProto::VT_PRIMARY_KEY, primary_key);
  }
  explicit ServiceReferenceValueProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ServiceReferenceValueProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServiceReferenceValueProto>(end);
    fbb_.Required(o, ServiceReferenceValueProto::VT_PRIMARY_KEY);
    return o;
  }
};

inline flatbuffers::Offset<ServiceReferenceValueProto> CreateServiceReferenceValueProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    flatbuffers::Offset<flatbuffers::String> primary_key = 0) {
  ServiceReferenceValueProtoBuilder builder_(_fbb);
  builder_.add_primary_key(primary_key);
  builder_.add_class_id(class_id);
  return builder_.Finish();
}

struct ServiceReferenceValueProto::Traits {
  using type = ServiceReferenceValueProto;
  static auto constexpr Create = CreateServiceReferenceValueProto;
};

inline flatbuffers::Offset<ServiceReferenceValueProto> CreateServiceReferenceValueProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    const char *primary_key = nullptr) {
  auto primary_key__ = primary_key ? _fbb.CreateString(primary_key) : 0;
  return CreateServiceReferenceValueProto(
      _fbb,
      class_id,
      primary_key__);
}

struct MapValueItemProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapValueItemProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ValueProto *key() const {
    return GetPointer<const ValueProto *>(VT_KEY);
  }
  const ValueProto *value() const {
    return GetPointer<const ValueProto *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyTable(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct MapValueItemProtoBuilder {
  typedef MapValueItemProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<ValueProto> key) {
    fbb_.AddOffset(MapValueItemProto::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<ValueProto> value) {
    fbb_.AddOffset(MapValueItemProto::VT_VALUE, value);
  }
  explicit MapValueItemProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapValueItemProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapValueItemProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapValueItemProto> CreateMapValueItemProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ValueProto> key = 0,
    flatbuffers::Offset<ValueProto> value = 0) {
  MapValueItemProtoBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct MapValueItemProto::Traits {
  using type = MapValueItemProto;
  static auto constexpr Create = CreateMapValueItemProto;
};

struct MapValueProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapValueProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<MapValueItemProto>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MapValueItemProto>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct MapValueProtoBuilder {
  typedef MapValueProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapValueItemProto>>> items) {
    fbb_.AddOffset(MapValueProto::VT_ITEMS, items);
  }
  explicit MapValueProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapValueProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapValueProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapValueProto> CreateMapValueProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapValueItemProto>>> items = 0) {
  MapValueProtoBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

struct MapValueProto::Traits {
  using type = MapValueProto;
  static auto constexpr Create = CreateMapValueProto;
};

inline flatbuffers::Offset<MapValueProto> CreateMapValueProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<MapValueItemProto>> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<flatbuffers::Offset<MapValueItemProto>>(*items) : 0;
  return CreateMapValueProto(
      _fbb,
      items__);
}

struct SetValueProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetValueProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ValueProto>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ValueProto>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct SetValueProtoBuilder {
  typedef SetValueProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ValueProto>>> items) {
    fbb_.AddOffset(SetValueProto::VT_ITEMS, items);
  }
  explicit SetValueProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SetValueProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetValueProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetValueProto> CreateSetValueProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ValueProto>>> items = 0) {
  SetValueProtoBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

struct SetValueProto::Traits {
  using type = SetValueProto;
  static auto constexpr Create = CreateSetValueProto;
};

inline flatbuffers::Offset<SetValueProto> CreateSetValueProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ValueProto>> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<flatbuffers::Offset<ValueProto>>(*items) : 0;
  return CreateSetValueProto(
      _fbb,
      items__);
}

struct DateValueProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DateValueProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DateValueProtoBuilder {
  typedef DateValueProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(DateValueProto::VT_VALUE, value, 0.0);
  }
  explicit DateValueProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DateValueProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DateValueProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<DateValueProto> CreateDateValueProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  DateValueProtoBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DateValueProto::Traits {
  using type = DateValueProto;
  static auto constexpr Create = CreateDateValueProto;
};

struct MessageProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_SOURCE_TYPE = 6,
    VT_SOURCE = 8,
    VT_PROPERTIES = 10,
    VT_REFERENCED_DATA_HANDLES = 12
  };
  uint16_t class_id() const {
    return GetField<uint16_t>(VT_CLASS_ID, 0);
  }
  WorkerReferenceUnionProto source_type() const {
    return static_cast<WorkerReferenceUnionProto>(GetField<uint8_t>(VT_SOURCE_TYPE, 0));
  }
  const void *source() const {
    return GetPointer<const void *>(VT_SOURCE);
  }
  template<typename T> const T *source_as() const;
  const DataReferenceValueProto *source_as_DataReferenceValueProto() const {
    return source_type() == WorkerReferenceUnionProto::DataReferenceValueProto ? static_cast<const DataReferenceValueProto *>(source()) : nullptr;
  }
  const ServiceReferenceValueProto *source_as_ServiceReferenceValueProto() const {
    return source_type() == WorkerReferenceUnionProto::ServiceReferenceValueProto ? static_cast<const ServiceReferenceValueProto *>(source()) : nullptr;
  }
  const flatbuffers::Vector<flatbuffers::Offset<PropertyProto>> *properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PropertyProto>> *>(VT_PROPERTIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DataHandleProto>> *referenced_data_handles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DataHandleProto>> *>(VT_REFERENCED_DATA_HANDLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CLASS_ID) &&
           VerifyField<uint8_t>(verifier, VT_SOURCE_TYPE) &&
           VerifyOffsetRequired(verifier, VT_SOURCE) &&
           VerifyWorkerReferenceUnionProto(verifier, source(), source_type()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           VerifyOffset(verifier, VT_REFERENCED_DATA_HANDLES) &&
           verifier.VerifyVector(referenced_data_handles()) &&
           verifier.VerifyVectorOfTables(referenced_data_handles()) &&
           verifier.EndTable();
  }
};

template<> inline const DataReferenceValueProto *MessageProto::source_as<DataReferenceValueProto>() const {
  return source_as_DataReferenceValueProto();
}

template<> inline const ServiceReferenceValueProto *MessageProto::source_as<ServiceReferenceValueProto>() const {
  return source_as_ServiceReferenceValueProto();
}

struct MessageProtoBuilder {
  typedef MessageProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_class_id(uint16_t class_id) {
    fbb_.AddElement<uint16_t>(MessageProto::VT_CLASS_ID, class_id, 0);
  }
  void add_source_type(WorkerReferenceUnionProto source_type) {
    fbb_.AddElement<uint8_t>(MessageProto::VT_SOURCE_TYPE, static_cast<uint8_t>(source_type), 0);
  }
  void add_source(flatbuffers::Offset<void> source) {
    fbb_.AddOffset(MessageProto::VT_SOURCE, source);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PropertyProto>>> properties) {
    fbb_.AddOffset(MessageProto::VT_PROPERTIES, properties);
  }
  void add_referenced_data_handles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataHandleProto>>> referenced_data_handles) {
    fbb_.AddOffset(MessageProto::VT_REFERENCED_DATA_HANDLES, referenced_data_handles);
  }
  explicit MessageProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MessageProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageProto>(end);
    fbb_.Required(o, MessageProto::VT_SOURCE);
    return o;
  }
};

inline flatbuffers::Offset<MessageProto> CreateMessageProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    WorkerReferenceUnionProto source_type = WorkerReferenceUnionProto::NONE,
    flatbuffers::Offset<void> source = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PropertyProto>>> properties = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataHandleProto>>> referenced_data_handles = 0) {
  MessageProtoBuilder builder_(_fbb);
  builder_.add_referenced_data_handles(referenced_data_handles);
  builder_.add_properties(properties);
  builder_.add_source(source);
  builder_.add_class_id(class_id);
  builder_.add_source_type(source_type);
  return builder_.Finish();
}

struct MessageProto::Traits {
  using type = MessageProto;
  static auto constexpr Create = CreateMessageProto;
};

inline flatbuffers::Offset<MessageProto> CreateMessageProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    WorkerReferenceUnionProto source_type = WorkerReferenceUnionProto::NONE,
    flatbuffers::Offset<void> source = 0,
    const std::vector<flatbuffers::Offset<PropertyProto>> *properties = nullptr,
    const std::vector<flatbuffers::Offset<DataHandleProto>> *referenced_data_handles = nullptr) {
  auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<PropertyProto>>(*properties) : 0;
  auto referenced_data_handles__ = referenced_data_handles ? _fbb.CreateVector<flatbuffers::Offset<DataHandleProto>>(*referenced_data_handles) : 0;
  return CreateMessageProto(
      _fbb,
      class_id,
      source_type,
      source,
      properties__,
      referenced_data_handles__);
}

struct MessageBytesProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageBytesProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BYTES = 4
  };
  const flatbuffers::Vector<uint8_t> *bytes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BYTES);
  }
  const MessageProto *bytes_nested_root() const {
    return flatbuffers::GetRoot<MessageProto>(bytes()->Data());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BYTES) &&
           verifier.VerifyVector(bytes()) &&
           verifier.EndTable();
  }
};

struct MessageBytesProtoBuilder {
  typedef MessageBytesProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bytes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes) {
    fbb_.AddOffset(MessageBytesProto::VT_BYTES, bytes);
  }
  explicit MessageBytesProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MessageBytesProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageBytesProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageBytesProto> CreateMessageBytesProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes = 0) {
  MessageBytesProtoBuilder builder_(_fbb);
  builder_.add_bytes(bytes);
  return builder_.Finish();
}

struct MessageBytesProto::Traits {
  using type = MessageBytesProto;
  static auto constexpr Create = CreateMessageBytesProto;
};

inline flatbuffers::Offset<MessageBytesProto> CreateMessageBytesProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *bytes = nullptr) {
  auto bytes__ = bytes ? _fbb.CreateVector<uint8_t>(*bytes) : 0;
  return CreateMessageBytesProto(
      _fbb,
      bytes__);
}

struct DataDeltaBytesProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataDeltaBytesProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BYTES = 4
  };
  const flatbuffers::Vector<uint8_t> *bytes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BYTES);
  }
  const DataDeltaProto *bytes_nested_root() const {
    return flatbuffers::GetRoot<DataDeltaProto>(bytes()->Data());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BYTES) &&
           verifier.VerifyVector(bytes()) &&
           verifier.EndTable();
  }
};

struct DataDeltaBytesProtoBuilder {
  typedef DataDeltaBytesProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bytes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes) {
    fbb_.AddOffset(DataDeltaBytesProto::VT_BYTES, bytes);
  }
  explicit DataDeltaBytesProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataDeltaBytesProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataDeltaBytesProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataDeltaBytesProto> CreateDataDeltaBytesProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes = 0) {
  DataDeltaBytesProtoBuilder builder_(_fbb);
  builder_.add_bytes(bytes);
  return builder_.Finish();
}

struct DataDeltaBytesProto::Traits {
  using type = DataDeltaBytesProto;
  static auto constexpr Create = CreateDataDeltaBytesProto;
};

inline flatbuffers::Offset<DataDeltaBytesProto> CreateDataDeltaBytesProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *bytes = nullptr) {
  auto bytes__ = bytes ? _fbb.CreateVector<uint8_t>(*bytes) : 0;
  return CreateDataDeltaBytesProto(
      _fbb,
      bytes__);
}

struct InboundDataDeltaProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InboundDataDeltaProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_OBJECT_VERSION = 6,
    VT_PRIMARY_KEY = 8,
    VT_PROPERTIES = 10,
    VT_DELETED_PROPERTIES = 12
  };
  uint16_t class_id() const {
    return GetField<uint16_t>(VT_CLASS_ID, 0);
  }
  uint64_t object_version() const {
    return GetField<uint64_t>(VT_OBJECT_VERSION, 0);
  }
  const flatbuffers::String *primary_key() const {
    return GetPointer<const flatbuffers::String *>(VT_PRIMARY_KEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NestedPropertyProto>> *properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NestedPropertyProto>> *>(VT_PROPERTIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *deleted_properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DELETED_PROPERTIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CLASS_ID) &&
           VerifyField<uint64_t>(verifier, VT_OBJECT_VERSION) &&
           VerifyOffsetRequired(verifier, VT_PRIMARY_KEY) &&
           verifier.VerifyString(primary_key()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           VerifyOffset(verifier, VT_DELETED_PROPERTIES) &&
           verifier.VerifyVector(deleted_properties()) &&
           verifier.VerifyVectorOfStrings(deleted_properties()) &&
           verifier.EndTable();
  }
};

struct InboundDataDeltaProtoBuilder {
  typedef InboundDataDeltaProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_class_id(uint16_t class_id) {
    fbb_.AddElement<uint16_t>(InboundDataDeltaProto::VT_CLASS_ID, class_id, 0);
  }
  void add_object_version(uint64_t object_version) {
    fbb_.AddElement<uint64_t>(InboundDataDeltaProto::VT_OBJECT_VERSION, object_version, 0);
  }
  void add_primary_key(flatbuffers::Offset<flatbuffers::String> primary_key) {
    fbb_.AddOffset(InboundDataDeltaProto::VT_PRIMARY_KEY, primary_key);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NestedPropertyProto>>> properties) {
    fbb_.AddOffset(InboundDataDeltaProto::VT_PROPERTIES, properties);
  }
  void add_deleted_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> deleted_properties) {
    fbb_.AddOffset(InboundDataDeltaProto::VT_DELETED_PROPERTIES, deleted_properties);
  }
  explicit InboundDataDeltaProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InboundDataDeltaProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InboundDataDeltaProto>(end);
    fbb_.Required(o, InboundDataDeltaProto::VT_PRIMARY_KEY);
    return o;
  }
};

inline flatbuffers::Offset<InboundDataDeltaProto> CreateInboundDataDeltaProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    uint64_t object_version = 0,
    flatbuffers::Offset<flatbuffers::String> primary_key = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NestedPropertyProto>>> properties = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> deleted_properties = 0) {
  InboundDataDeltaProtoBuilder builder_(_fbb);
  builder_.add_object_version(object_version);
  builder_.add_deleted_properties(deleted_properties);
  builder_.add_properties(properties);
  builder_.add_primary_key(primary_key);
  builder_.add_class_id(class_id);
  return builder_.Finish();
}

struct InboundDataDeltaProto::Traits {
  using type = InboundDataDeltaProto;
  static auto constexpr Create = CreateInboundDataDeltaProto;
};

inline flatbuffers::Offset<InboundDataDeltaProto> CreateInboundDataDeltaProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    uint64_t object_version = 0,
    const char *primary_key = nullptr,
    const std::vector<flatbuffers::Offset<NestedPropertyProto>> *properties = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *deleted_properties = nullptr) {
  auto primary_key__ = primary_key ? _fbb.CreateString(primary_key) : 0;
  auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<NestedPropertyProto>>(*properties) : 0;
  auto deleted_properties__ = deleted_properties ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*deleted_properties) : 0;
  return CreateInboundDataDeltaProto(
      _fbb,
      class_id,
      object_version,
      primary_key__,
      properties__,
      deleted_properties__);
}

struct DataDeltaProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataDeltaProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_OBJECT_VERSION = 6,
    VT_PRIMARY_KEY = 8,
    VT_DELETED = 10,
    VT_PROPERTIES = 12,
    VT_DELETED_PROPERTIES = 14
  };
  uint16_t class_id() const {
    return GetField<uint16_t>(VT_CLASS_ID, 0);
  }
  uint64_t object_version() const {
    return GetField<uint64_t>(VT_OBJECT_VERSION, 0);
  }
  const flatbuffers::String *primary_key() const {
    return GetPointer<const flatbuffers::String *>(VT_PRIMARY_KEY);
  }
  bool deleted() const {
    return GetField<uint8_t>(VT_DELETED, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<NestedPropertyProto>> *properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NestedPropertyProto>> *>(VT_PROPERTIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *deleted_properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DELETED_PROPERTIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CLASS_ID) &&
           VerifyField<uint64_t>(verifier, VT_OBJECT_VERSION) &&
           VerifyOffsetRequired(verifier, VT_PRIMARY_KEY) &&
           verifier.VerifyString(primary_key()) &&
           VerifyField<uint8_t>(verifier, VT_DELETED) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           VerifyOffset(verifier, VT_DELETED_PROPERTIES) &&
           verifier.VerifyVector(deleted_properties()) &&
           verifier.VerifyVectorOfStrings(deleted_properties()) &&
           verifier.EndTable();
  }
};

struct DataDeltaProtoBuilder {
  typedef DataDeltaProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_class_id(uint16_t class_id) {
    fbb_.AddElement<uint16_t>(DataDeltaProto::VT_CLASS_ID, class_id, 0);
  }
  void add_object_version(uint64_t object_version) {
    fbb_.AddElement<uint64_t>(DataDeltaProto::VT_OBJECT_VERSION, object_version, 0);
  }
  void add_primary_key(flatbuffers::Offset<flatbuffers::String> primary_key) {
    fbb_.AddOffset(DataDeltaProto::VT_PRIMARY_KEY, primary_key);
  }
  void add_deleted(bool deleted) {
    fbb_.AddElement<uint8_t>(DataDeltaProto::VT_DELETED, static_cast<uint8_t>(deleted), 0);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NestedPropertyProto>>> properties) {
    fbb_.AddOffset(DataDeltaProto::VT_PROPERTIES, properties);
  }
  void add_deleted_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> deleted_properties) {
    fbb_.AddOffset(DataDeltaProto::VT_DELETED_PROPERTIES, deleted_properties);
  }
  explicit DataDeltaProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataDeltaProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataDeltaProto>(end);
    fbb_.Required(o, DataDeltaProto::VT_PRIMARY_KEY);
    return o;
  }
};

inline flatbuffers::Offset<DataDeltaProto> CreateDataDeltaProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    uint64_t object_version = 0,
    flatbuffers::Offset<flatbuffers::String> primary_key = 0,
    bool deleted = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NestedPropertyProto>>> properties = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> deleted_properties = 0) {
  DataDeltaProtoBuilder builder_(_fbb);
  builder_.add_object_version(object_version);
  builder_.add_deleted_properties(deleted_properties);
  builder_.add_properties(properties);
  builder_.add_primary_key(primary_key);
  builder_.add_class_id(class_id);
  builder_.add_deleted(deleted);
  return builder_.Finish();
}

struct DataDeltaProto::Traits {
  using type = DataDeltaProto;
  static auto constexpr Create = CreateDataDeltaProto;
};

inline flatbuffers::Offset<DataDeltaProto> CreateDataDeltaProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    uint64_t object_version = 0,
    const char *primary_key = nullptr,
    bool deleted = false,
    const std::vector<flatbuffers::Offset<NestedPropertyProto>> *properties = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *deleted_properties = nullptr) {
  auto primary_key__ = primary_key ? _fbb.CreateString(primary_key) : 0;
  auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<NestedPropertyProto>>(*properties) : 0;
  auto deleted_properties__ = deleted_properties ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*deleted_properties) : 0;
  return CreateDataDeltaProto(
      _fbb,
      class_id,
      object_version,
      primary_key__,
      deleted,
      properties__,
      deleted_properties__);
}

struct DataHandleProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataHandleProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_OBJECT_VERSION = 6,
    VT_PRIMARY_KEY = 8
  };
  uint16_t class_id() const {
    return GetField<uint16_t>(VT_CLASS_ID, 0);
  }
  uint64_t object_version() const {
    return GetField<uint64_t>(VT_OBJECT_VERSION, 0);
  }
  const flatbuffers::String *primary_key() const {
    return GetPointer<const flatbuffers::String *>(VT_PRIMARY_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CLASS_ID) &&
           VerifyField<uint64_t>(verifier, VT_OBJECT_VERSION) &&
           VerifyOffsetRequired(verifier, VT_PRIMARY_KEY) &&
           verifier.VerifyString(primary_key()) &&
           verifier.EndTable();
  }
};

struct DataHandleProtoBuilder {
  typedef DataHandleProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_class_id(uint16_t class_id) {
    fbb_.AddElement<uint16_t>(DataHandleProto::VT_CLASS_ID, class_id, 0);
  }
  void add_object_version(uint64_t object_version) {
    fbb_.AddElement<uint64_t>(DataHandleProto::VT_OBJECT_VERSION, object_version, 0);
  }
  void add_primary_key(flatbuffers::Offset<flatbuffers::String> primary_key) {
    fbb_.AddOffset(DataHandleProto::VT_PRIMARY_KEY, primary_key);
  }
  explicit DataHandleProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataHandleProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataHandleProto>(end);
    fbb_.Required(o, DataHandleProto::VT_PRIMARY_KEY);
    return o;
  }
};

inline flatbuffers::Offset<DataHandleProto> CreateDataHandleProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    uint64_t object_version = 0,
    flatbuffers::Offset<flatbuffers::String> primary_key = 0) {
  DataHandleProtoBuilder builder_(_fbb);
  builder_.add_object_version(object_version);
  builder_.add_primary_key(primary_key);
  builder_.add_class_id(class_id);
  return builder_.Finish();
}

struct DataHandleProto::Traits {
  using type = DataHandleProto;
  static auto constexpr Create = CreateDataHandleProto;
};

inline flatbuffers::Offset<DataHandleProto> CreateDataHandleProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    uint64_t object_version = 0,
    const char *primary_key = nullptr) {
  auto primary_key__ = primary_key ? _fbb.CreateString(primary_key) : 0;
  return CreateDataHandleProto(
      _fbb,
      class_id,
      object_version,
      primary_key__);
}

struct DataProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_OBJECT_VERSION = 6,
    VT_PRIMARY_KEY = 8,
    VT_DELETED = 10,
    VT_PROPERTIES = 12
  };
  uint16_t class_id() const {
    return GetField<uint16_t>(VT_CLASS_ID, 0);
  }
  uint64_t object_version() const {
    return GetField<uint64_t>(VT_OBJECT_VERSION, 0);
  }
  const flatbuffers::String *primary_key() const {
    return GetPointer<const flatbuffers::String *>(VT_PRIMARY_KEY);
  }
  bool deleted() const {
    return GetField<uint8_t>(VT_DELETED, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<PropertyProto>> *properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PropertyProto>> *>(VT_PROPERTIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CLASS_ID) &&
           VerifyField<uint64_t>(verifier, VT_OBJECT_VERSION) &&
           VerifyOffsetRequired(verifier, VT_PRIMARY_KEY) &&
           verifier.VerifyString(primary_key()) &&
           VerifyField<uint8_t>(verifier, VT_DELETED) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           verifier.EndTable();
  }
};

struct DataProtoBuilder {
  typedef DataProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_class_id(uint16_t class_id) {
    fbb_.AddElement<uint16_t>(DataProto::VT_CLASS_ID, class_id, 0);
  }
  void add_object_version(uint64_t object_version) {
    fbb_.AddElement<uint64_t>(DataProto::VT_OBJECT_VERSION, object_version, 0);
  }
  void add_primary_key(flatbuffers::Offset<flatbuffers::String> primary_key) {
    fbb_.AddOffset(DataProto::VT_PRIMARY_KEY, primary_key);
  }
  void add_deleted(bool deleted) {
    fbb_.AddElement<uint8_t>(DataProto::VT_DELETED, static_cast<uint8_t>(deleted), 0);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PropertyProto>>> properties) {
    fbb_.AddOffset(DataProto::VT_PROPERTIES, properties);
  }
  explicit DataProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataProto>(end);
    fbb_.Required(o, DataProto::VT_PRIMARY_KEY);
    return o;
  }
};

inline flatbuffers::Offset<DataProto> CreateDataProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    uint64_t object_version = 0,
    flatbuffers::Offset<flatbuffers::String> primary_key = 0,
    bool deleted = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PropertyProto>>> properties = 0) {
  DataProtoBuilder builder_(_fbb);
  builder_.add_object_version(object_version);
  builder_.add_properties(properties);
  builder_.add_primary_key(primary_key);
  builder_.add_class_id(class_id);
  builder_.add_deleted(deleted);
  return builder_.Finish();
}

struct DataProto::Traits {
  using type = DataProto;
  static auto constexpr Create = CreateDataProto;
};

inline flatbuffers::Offset<DataProto> CreateDataProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    uint64_t object_version = 0,
    const char *primary_key = nullptr,
    bool deleted = false,
    const std::vector<flatbuffers::Offset<PropertyProto>> *properties = nullptr) {
  auto primary_key__ = primary_key ? _fbb.CreateString(primary_key) : 0;
  auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<PropertyProto>>(*properties) : 0;
  return CreateDataProto(
      _fbb,
      class_id,
      object_version,
      primary_key__,
      deleted,
      properties__);
}

struct NestedDataProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NestedDataProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_OBJECT_VERSION = 6,
    VT_PRIMARY_KEY = 8,
    VT_DELETED = 10,
    VT_PROPERTIES = 12
  };
  uint16_t class_id() const {
    return GetField<uint16_t>(VT_CLASS_ID, 0);
  }
  uint64_t object_version() const {
    return GetField<uint64_t>(VT_OBJECT_VERSION, 0);
  }
  const flatbuffers::String *primary_key() const {
    return GetPointer<const flatbuffers::String *>(VT_PRIMARY_KEY);
  }
  bool deleted() const {
    return GetField<uint8_t>(VT_DELETED, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<NestedPropertyProto>> *properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NestedPropertyProto>> *>(VT_PROPERTIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CLASS_ID) &&
           VerifyField<uint64_t>(verifier, VT_OBJECT_VERSION) &&
           VerifyOffsetRequired(verifier, VT_PRIMARY_KEY) &&
           verifier.VerifyString(primary_key()) &&
           VerifyField<uint8_t>(verifier, VT_DELETED) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           verifier.EndTable();
  }
};

struct NestedDataProtoBuilder {
  typedef NestedDataProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_class_id(uint16_t class_id) {
    fbb_.AddElement<uint16_t>(NestedDataProto::VT_CLASS_ID, class_id, 0);
  }
  void add_object_version(uint64_t object_version) {
    fbb_.AddElement<uint64_t>(NestedDataProto::VT_OBJECT_VERSION, object_version, 0);
  }
  void add_primary_key(flatbuffers::Offset<flatbuffers::String> primary_key) {
    fbb_.AddOffset(NestedDataProto::VT_PRIMARY_KEY, primary_key);
  }
  void add_deleted(bool deleted) {
    fbb_.AddElement<uint8_t>(NestedDataProto::VT_DELETED, static_cast<uint8_t>(deleted), 0);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NestedPropertyProto>>> properties) {
    fbb_.AddOffset(NestedDataProto::VT_PROPERTIES, properties);
  }
  explicit NestedDataProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NestedDataProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NestedDataProto>(end);
    fbb_.Required(o, NestedDataProto::VT_PRIMARY_KEY);
    return o;
  }
};

inline flatbuffers::Offset<NestedDataProto> CreateNestedDataProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    uint64_t object_version = 0,
    flatbuffers::Offset<flatbuffers::String> primary_key = 0,
    bool deleted = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NestedPropertyProto>>> properties = 0) {
  NestedDataProtoBuilder builder_(_fbb);
  builder_.add_object_version(object_version);
  builder_.add_properties(properties);
  builder_.add_primary_key(primary_key);
  builder_.add_class_id(class_id);
  builder_.add_deleted(deleted);
  return builder_.Finish();
}

struct NestedDataProto::Traits {
  using type = NestedDataProto;
  static auto constexpr Create = CreateNestedDataProto;
};

inline flatbuffers::Offset<NestedDataProto> CreateNestedDataProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    uint64_t object_version = 0,
    const char *primary_key = nullptr,
    bool deleted = false,
    const std::vector<flatbuffers::Offset<NestedPropertyProto>> *properties = nullptr) {
  auto primary_key__ = primary_key ? _fbb.CreateString(primary_key) : 0;
  auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<NestedPropertyProto>>(*properties) : 0;
  return CreateNestedDataProto(
      _fbb,
      class_id,
      object_version,
      primary_key__,
      deleted,
      properties__);
}

inline bool VerifyValueUnionProto(flatbuffers::Verifier &verifier, const void *obj, ValueUnionProto type) {
  switch (type) {
    case ValueUnionProto::NONE: {
      return true;
    }
    case ValueUnionProto::UndefinedValueProto: {
      auto ptr = reinterpret_cast<const UndefinedValueProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnionProto::NullValueProto: {
      auto ptr = reinterpret_cast<const NullValueProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnionProto::BooleanValueProto: {
      auto ptr = reinterpret_cast<const BooleanValueProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnionProto::StringValueProto: {
      auto ptr = reinterpret_cast<const StringValueProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnionProto::NumberValueProto: {
      auto ptr = reinterpret_cast<const NumberValueProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnionProto::ObjectValueProto: {
      auto ptr = reinterpret_cast<const ObjectValueProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnionProto::ArrayValueProto: {
      auto ptr = reinterpret_cast<const ArrayValueProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnionProto::DataReferenceValueProto: {
      auto ptr = reinterpret_cast<const DataReferenceValueProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnionProto::ServiceReferenceValueProto: {
      auto ptr = reinterpret_cast<const ServiceReferenceValueProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnionProto::MapValueProto: {
      auto ptr = reinterpret_cast<const MapValueProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnionProto::SetValueProto: {
      auto ptr = reinterpret_cast<const SetValueProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnionProto::DateValueProto: {
      auto ptr = reinterpret_cast<const DateValueProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueUnionProtoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValueUnionProto(
        verifier,  values->Get(i), types->GetEnum<ValueUnionProto>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyWorkerReferenceUnionProto(flatbuffers::Verifier &verifier, const void *obj, WorkerReferenceUnionProto type) {
  switch (type) {
    case WorkerReferenceUnionProto::NONE: {
      return true;
    }
    case WorkerReferenceUnionProto::DataReferenceValueProto: {
      auto ptr = reinterpret_cast<const DataReferenceValueProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case WorkerReferenceUnionProto::ServiceReferenceValueProto: {
      auto ptr = reinterpret_cast<const ServiceReferenceValueProto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyWorkerReferenceUnionProtoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyWorkerReferenceUnionProto(
        verifier,  values->Get(i), types->GetEnum<WorkerReferenceUnionProto>(i))) {
      return false;
    }
  }
  return true;
}

#endif  // FLATBUFFERS_GENERATED_MODEL_H_
