// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WORKERINDEXPROTO_H_
#define FLATBUFFERS_GENERATED_WORKERINDEXPROTO_H_

#include "flatbuffers/flatbuffers.h"

struct ConstructorProto;
struct ConstructorProtoBuilder;

struct MethodArgumentProto;
struct MethodArgumentProtoBuilder;

struct MethodProto;
struct MethodProtoBuilder;

struct WorkerFileNameProto;
struct WorkerFileNameProtoBuilder;

struct ServiceMethodProto;
struct ServiceMethodProtoBuilder;

struct ServiceClassProto;
struct ServiceClassProtoBuilder;

struct DataClassProto;
struct DataClassProtoBuilder;

struct MessageClassProto;
struct MessageClassProtoBuilder;

struct FreeFunctionProto;
struct FreeFunctionProtoBuilder;

struct FreeClassProto;
struct FreeClassProtoBuilder;

struct WorkerIndexProto;
struct WorkerIndexProtoBuilder;

enum class MethodKindProto : uint8_t {
  Getter = 1,
  Setter = 2,
  Normal = 3,
  MIN = Getter,
  MAX = Normal
};

inline const MethodKindProto (&EnumValuesMethodKindProto())[3] {
  static const MethodKindProto values[] = {
    MethodKindProto::Getter,
    MethodKindProto::Setter,
    MethodKindProto::Normal
  };
  return values;
}

inline const char * const *EnumNamesMethodKindProto() {
  static const char * const names[4] = {
    "Getter",
    "Setter",
    "Normal",
    nullptr
  };
  return names;
}

inline const char *EnumNameMethodKindProto(MethodKindProto e) {
  if (flatbuffers::IsOutRange(e, MethodKindProto::Getter, MethodKindProto::Normal)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(MethodKindProto::Getter);
  return EnumNamesMethodKindProto()[index];
}

struct ConstructorProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConstructorProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARGUMENTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>> *>(VT_ARGUMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           verifier.EndTable();
  }
};

struct ConstructorProtoBuilder {
  typedef ConstructorProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>>> arguments) {
    fbb_.AddOffset(ConstructorProto::VT_ARGUMENTS, arguments);
  }
  explicit ConstructorProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConstructorProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConstructorProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConstructorProto> CreateConstructorProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>>> arguments = 0) {
  ConstructorProtoBuilder builder_(_fbb);
  builder_.add_arguments(arguments);
  return builder_.Finish();
}

struct ConstructorProto::Traits {
  using type = ConstructorProto;
  static auto constexpr Create = CreateConstructorProto;
};

inline flatbuffers::Offset<ConstructorProto> CreateConstructorProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<MethodArgumentProto>> *arguments = nullptr) {
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<MethodArgumentProto>>(*arguments) : 0;
  return CreateConstructorProto(
      _fbb,
      arguments__);
}

struct MethodArgumentProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodArgumentProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           verifier.EndTable();
  }
};

struct MethodArgumentProtoBuilder {
  typedef MethodArgumentProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MethodArgumentProto::VT_NAME, name);
  }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(MethodArgumentProto::VT_TYPE, type);
  }
  explicit MethodArgumentProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MethodArgumentProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodArgumentProto>(end);
    fbb_.Required(o, MethodArgumentProto::VT_NAME);
    fbb_.Required(o, MethodArgumentProto::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<MethodArgumentProto> CreateMethodArgumentProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> type = 0) {
  MethodArgumentProtoBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_name(name);
  return builder_.Finish();
}

struct MethodArgumentProto::Traits {
  using type = MethodArgumentProto;
  static auto constexpr Create = CreateMethodArgumentProto;
};

inline flatbuffers::Offset<MethodArgumentProto> CreateMethodArgumentProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *type = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  return CreateMethodArgumentProto(
      _fbb,
      name__,
      type__);
}

struct MethodProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MethodProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD_NAME = 4,
    VT_METHOD_KIND = 6,
    VT_ARGUMENTS = 8,
    VT_RETURN_TYPE = 10
  };
  const flatbuffers::String *method_name() const {
    return GetPointer<const flatbuffers::String *>(VT_METHOD_NAME);
  }
  MethodKindProto method_kind() const {
    return static_cast<MethodKindProto>(GetField<uint8_t>(VT_METHOD_KIND, 3));
  }
  const flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>> *>(VT_ARGUMENTS);
  }
  const flatbuffers::String *return_type() const {
    return GetPointer<const flatbuffers::String *>(VT_RETURN_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_METHOD_NAME) &&
           verifier.VerifyString(method_name()) &&
           VerifyField<uint8_t>(verifier, VT_METHOD_KIND) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           VerifyOffset(verifier, VT_RETURN_TYPE) &&
           verifier.VerifyString(return_type()) &&
           verifier.EndTable();
  }
};

struct MethodProtoBuilder {
  typedef MethodProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_method_name(flatbuffers::Offset<flatbuffers::String> method_name) {
    fbb_.AddOffset(MethodProto::VT_METHOD_NAME, method_name);
  }
  void add_method_kind(MethodKindProto method_kind) {
    fbb_.AddElement<uint8_t>(MethodProto::VT_METHOD_KIND, static_cast<uint8_t>(method_kind), 3);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>>> arguments) {
    fbb_.AddOffset(MethodProto::VT_ARGUMENTS, arguments);
  }
  void add_return_type(flatbuffers::Offset<flatbuffers::String> return_type) {
    fbb_.AddOffset(MethodProto::VT_RETURN_TYPE, return_type);
  }
  explicit MethodProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MethodProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MethodProto>(end);
    fbb_.Required(o, MethodProto::VT_METHOD_NAME);
    return o;
  }
};

inline flatbuffers::Offset<MethodProto> CreateMethodProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> method_name = 0,
    MethodKindProto method_kind = MethodKindProto::Normal,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>>> arguments = 0,
    flatbuffers::Offset<flatbuffers::String> return_type = 0) {
  MethodProtoBuilder builder_(_fbb);
  builder_.add_return_type(return_type);
  builder_.add_arguments(arguments);
  builder_.add_method_name(method_name);
  builder_.add_method_kind(method_kind);
  return builder_.Finish();
}

struct MethodProto::Traits {
  using type = MethodProto;
  static auto constexpr Create = CreateMethodProto;
};

inline flatbuffers::Offset<MethodProto> CreateMethodProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *method_name = nullptr,
    MethodKindProto method_kind = MethodKindProto::Normal,
    const std::vector<flatbuffers::Offset<MethodArgumentProto>> *arguments = nullptr,
    const char *return_type = nullptr) {
  auto method_name__ = method_name ? _fbb.CreateString(method_name) : 0;
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<MethodArgumentProto>>(*arguments) : 0;
  auto return_type__ = return_type ? _fbb.CreateString(return_type) : 0;
  return CreateMethodProto(
      _fbb,
      method_name__,
      method_kind,
      arguments__,
      return_type__);
}

struct WorkerFileNameProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WorkerFileNameProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE_NAME_ID = 4,
    VT_FILE_NAME = 6
  };
  uint16_t file_name_id() const {
    return GetField<uint16_t>(VT_FILE_NAME_ID, 0);
  }
  const flatbuffers::String *file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_FILE_NAME_ID) &&
           VerifyOffsetRequired(verifier, VT_FILE_NAME) &&
           verifier.VerifyString(file_name()) &&
           verifier.EndTable();
  }
};

struct WorkerFileNameProtoBuilder {
  typedef WorkerFileNameProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file_name_id(uint16_t file_name_id) {
    fbb_.AddElement<uint16_t>(WorkerFileNameProto::VT_FILE_NAME_ID, file_name_id, 0);
  }
  void add_file_name(flatbuffers::Offset<flatbuffers::String> file_name) {
    fbb_.AddOffset(WorkerFileNameProto::VT_FILE_NAME, file_name);
  }
  explicit WorkerFileNameProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WorkerFileNameProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerFileNameProto>(end);
    fbb_.Required(o, WorkerFileNameProto::VT_FILE_NAME);
    return o;
  }
};

inline flatbuffers::Offset<WorkerFileNameProto> CreateWorkerFileNameProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t file_name_id = 0,
    flatbuffers::Offset<flatbuffers::String> file_name = 0) {
  WorkerFileNameProtoBuilder builder_(_fbb);
  builder_.add_file_name(file_name);
  builder_.add_file_name_id(file_name_id);
  return builder_.Finish();
}

struct WorkerFileNameProto::Traits {
  using type = WorkerFileNameProto;
  static auto constexpr Create = CreateWorkerFileNameProto;
};

inline flatbuffers::Offset<WorkerFileNameProto> CreateWorkerFileNameProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t file_name_id = 0,
    const char *file_name = nullptr) {
  auto file_name__ = file_name ? _fbb.CreateString(file_name) : 0;
  return CreateWorkerFileNameProto(
      _fbb,
      file_name_id,
      file_name__);
}

struct ServiceMethodProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServiceMethodProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD_ID = 4,
    VT_METHOD_NAME = 6,
    VT_ARGUMENTS = 8,
    VT_RETURN_TYPE = 10
  };
  uint16_t method_id() const {
    return GetField<uint16_t>(VT_METHOD_ID, 0);
  }
  const flatbuffers::String *method_name() const {
    return GetPointer<const flatbuffers::String *>(VT_METHOD_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>> *>(VT_ARGUMENTS);
  }
  const flatbuffers::String *return_type() const {
    return GetPointer<const flatbuffers::String *>(VT_RETURN_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_METHOD_ID) &&
           VerifyOffsetRequired(verifier, VT_METHOD_NAME) &&
           verifier.VerifyString(method_name()) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           VerifyOffset(verifier, VT_RETURN_TYPE) &&
           verifier.VerifyString(return_type()) &&
           verifier.EndTable();
  }
};

struct ServiceMethodProtoBuilder {
  typedef ServiceMethodProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_method_id(uint16_t method_id) {
    fbb_.AddElement<uint16_t>(ServiceMethodProto::VT_METHOD_ID, method_id, 0);
  }
  void add_method_name(flatbuffers::Offset<flatbuffers::String> method_name) {
    fbb_.AddOffset(ServiceMethodProto::VT_METHOD_NAME, method_name);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>>> arguments) {
    fbb_.AddOffset(ServiceMethodProto::VT_ARGUMENTS, arguments);
  }
  void add_return_type(flatbuffers::Offset<flatbuffers::String> return_type) {
    fbb_.AddOffset(ServiceMethodProto::VT_RETURN_TYPE, return_type);
  }
  explicit ServiceMethodProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ServiceMethodProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServiceMethodProto>(end);
    fbb_.Required(o, ServiceMethodProto::VT_METHOD_NAME);
    return o;
  }
};

inline flatbuffers::Offset<ServiceMethodProto> CreateServiceMethodProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t method_id = 0,
    flatbuffers::Offset<flatbuffers::String> method_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>>> arguments = 0,
    flatbuffers::Offset<flatbuffers::String> return_type = 0) {
  ServiceMethodProtoBuilder builder_(_fbb);
  builder_.add_return_type(return_type);
  builder_.add_arguments(arguments);
  builder_.add_method_name(method_name);
  builder_.add_method_id(method_id);
  return builder_.Finish();
}

struct ServiceMethodProto::Traits {
  using type = ServiceMethodProto;
  static auto constexpr Create = CreateServiceMethodProto;
};

inline flatbuffers::Offset<ServiceMethodProto> CreateServiceMethodProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t method_id = 0,
    const char *method_name = nullptr,
    const std::vector<flatbuffers::Offset<MethodArgumentProto>> *arguments = nullptr,
    const char *return_type = nullptr) {
  auto method_name__ = method_name ? _fbb.CreateString(method_name) : 0;
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<MethodArgumentProto>>(*arguments) : 0;
  auto return_type__ = return_type ? _fbb.CreateString(return_type) : 0;
  return CreateServiceMethodProto(
      _fbb,
      method_id,
      method_name__,
      arguments__,
      return_type__);
}

struct ServiceClassProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServiceClassProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_CLASS_NAME = 6,
    VT_FILE_NAME_ID = 8,
    VT_METHODS = 10
  };
  uint16_t class_id() const {
    return GetField<uint16_t>(VT_CLASS_ID, 0);
  }
  const flatbuffers::String *class_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CLASS_NAME);
  }
  uint16_t file_name_id() const {
    return GetField<uint16_t>(VT_FILE_NAME_ID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ServiceMethodProto>> *methods() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ServiceMethodProto>> *>(VT_METHODS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CLASS_ID) &&
           VerifyOffsetRequired(verifier, VT_CLASS_NAME) &&
           verifier.VerifyString(class_name()) &&
           VerifyField<uint16_t>(verifier, VT_FILE_NAME_ID) &&
           VerifyOffsetRequired(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           verifier.VerifyVectorOfTables(methods()) &&
           verifier.EndTable();
  }
};

struct ServiceClassProtoBuilder {
  typedef ServiceClassProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_class_id(uint16_t class_id) {
    fbb_.AddElement<uint16_t>(ServiceClassProto::VT_CLASS_ID, class_id, 0);
  }
  void add_class_name(flatbuffers::Offset<flatbuffers::String> class_name) {
    fbb_.AddOffset(ServiceClassProto::VT_CLASS_NAME, class_name);
  }
  void add_file_name_id(uint16_t file_name_id) {
    fbb_.AddElement<uint16_t>(ServiceClassProto::VT_FILE_NAME_ID, file_name_id, 0);
  }
  void add_methods(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ServiceMethodProto>>> methods) {
    fbb_.AddOffset(ServiceClassProto::VT_METHODS, methods);
  }
  explicit ServiceClassProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ServiceClassProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServiceClassProto>(end);
    fbb_.Required(o, ServiceClassProto::VT_CLASS_NAME);
    fbb_.Required(o, ServiceClassProto::VT_METHODS);
    return o;
  }
};

inline flatbuffers::Offset<ServiceClassProto> CreateServiceClassProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    flatbuffers::Offset<flatbuffers::String> class_name = 0,
    uint16_t file_name_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ServiceMethodProto>>> methods = 0) {
  ServiceClassProtoBuilder builder_(_fbb);
  builder_.add_methods(methods);
  builder_.add_class_name(class_name);
  builder_.add_file_name_id(file_name_id);
  builder_.add_class_id(class_id);
  return builder_.Finish();
}

struct ServiceClassProto::Traits {
  using type = ServiceClassProto;
  static auto constexpr Create = CreateServiceClassProto;
};

inline flatbuffers::Offset<ServiceClassProto> CreateServiceClassProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    const char *class_name = nullptr,
    uint16_t file_name_id = 0,
    const std::vector<flatbuffers::Offset<ServiceMethodProto>> *methods = nullptr) {
  auto class_name__ = class_name ? _fbb.CreateString(class_name) : 0;
  auto methods__ = methods ? _fbb.CreateVector<flatbuffers::Offset<ServiceMethodProto>>(*methods) : 0;
  return CreateServiceClassProto(
      _fbb,
      class_id,
      class_name__,
      file_name_id,
      methods__);
}

struct DataClassProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataClassProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_CLASS_NAME = 6,
    VT_SOURCE_CODE = 8,
    VT_FILE_NAME_ID = 10,
    VT_CTOR = 12,
    VT_METHODS = 14
  };
  uint16_t class_id() const {
    return GetField<uint16_t>(VT_CLASS_ID, 0);
  }
  const flatbuffers::String *class_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CLASS_NAME);
  }
  const flatbuffers::String *source_code() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCE_CODE);
  }
  uint16_t file_name_id() const {
    return GetField<uint16_t>(VT_FILE_NAME_ID, 0);
  }
  const ConstructorProto *ctor() const {
    return GetPointer<const ConstructorProto *>(VT_CTOR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MethodProto>> *methods() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MethodProto>> *>(VT_METHODS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CLASS_ID) &&
           VerifyOffsetRequired(verifier, VT_CLASS_NAME) &&
           verifier.VerifyString(class_name()) &&
           VerifyOffsetRequired(verifier, VT_SOURCE_CODE) &&
           verifier.VerifyString(source_code()) &&
           VerifyField<uint16_t>(verifier, VT_FILE_NAME_ID) &&
           VerifyOffsetRequired(verifier, VT_CTOR) &&
           verifier.VerifyTable(ctor()) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           verifier.VerifyVectorOfTables(methods()) &&
           verifier.EndTable();
  }
};

struct DataClassProtoBuilder {
  typedef DataClassProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_class_id(uint16_t class_id) {
    fbb_.AddElement<uint16_t>(DataClassProto::VT_CLASS_ID, class_id, 0);
  }
  void add_class_name(flatbuffers::Offset<flatbuffers::String> class_name) {
    fbb_.AddOffset(DataClassProto::VT_CLASS_NAME, class_name);
  }
  void add_source_code(flatbuffers::Offset<flatbuffers::String> source_code) {
    fbb_.AddOffset(DataClassProto::VT_SOURCE_CODE, source_code);
  }
  void add_file_name_id(uint16_t file_name_id) {
    fbb_.AddElement<uint16_t>(DataClassProto::VT_FILE_NAME_ID, file_name_id, 0);
  }
  void add_ctor(flatbuffers::Offset<ConstructorProto> ctor) {
    fbb_.AddOffset(DataClassProto::VT_CTOR, ctor);
  }
  void add_methods(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MethodProto>>> methods) {
    fbb_.AddOffset(DataClassProto::VT_METHODS, methods);
  }
  explicit DataClassProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataClassProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataClassProto>(end);
    fbb_.Required(o, DataClassProto::VT_CLASS_NAME);
    fbb_.Required(o, DataClassProto::VT_SOURCE_CODE);
    fbb_.Required(o, DataClassProto::VT_CTOR);
    return o;
  }
};

inline flatbuffers::Offset<DataClassProto> CreateDataClassProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    flatbuffers::Offset<flatbuffers::String> class_name = 0,
    flatbuffers::Offset<flatbuffers::String> source_code = 0,
    uint16_t file_name_id = 0,
    flatbuffers::Offset<ConstructorProto> ctor = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MethodProto>>> methods = 0) {
  DataClassProtoBuilder builder_(_fbb);
  builder_.add_methods(methods);
  builder_.add_ctor(ctor);
  builder_.add_source_code(source_code);
  builder_.add_class_name(class_name);
  builder_.add_file_name_id(file_name_id);
  builder_.add_class_id(class_id);
  return builder_.Finish();
}

struct DataClassProto::Traits {
  using type = DataClassProto;
  static auto constexpr Create = CreateDataClassProto;
};

inline flatbuffers::Offset<DataClassProto> CreateDataClassProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    const char *class_name = nullptr,
    const char *source_code = nullptr,
    uint16_t file_name_id = 0,
    flatbuffers::Offset<ConstructorProto> ctor = 0,
    const std::vector<flatbuffers::Offset<MethodProto>> *methods = nullptr) {
  auto class_name__ = class_name ? _fbb.CreateString(class_name) : 0;
  auto source_code__ = source_code ? _fbb.CreateString(source_code) : 0;
  auto methods__ = methods ? _fbb.CreateVector<flatbuffers::Offset<MethodProto>>(*methods) : 0;
  return CreateDataClassProto(
      _fbb,
      class_id,
      class_name__,
      source_code__,
      file_name_id,
      ctor,
      methods__);
}

struct MessageClassProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageClassProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ID = 4,
    VT_CLASS_NAME = 6,
    VT_SOURCE_CODE = 8,
    VT_FILE_NAME_ID = 10,
    VT_CTOR = 12,
    VT_METHODS = 14
  };
  uint16_t class_id() const {
    return GetField<uint16_t>(VT_CLASS_ID, 0);
  }
  const flatbuffers::String *class_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CLASS_NAME);
  }
  const flatbuffers::String *source_code() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCE_CODE);
  }
  uint16_t file_name_id() const {
    return GetField<uint16_t>(VT_FILE_NAME_ID, 0);
  }
  const ConstructorProto *ctor() const {
    return GetPointer<const ConstructorProto *>(VT_CTOR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MethodProto>> *methods() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MethodProto>> *>(VT_METHODS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CLASS_ID) &&
           VerifyOffsetRequired(verifier, VT_CLASS_NAME) &&
           verifier.VerifyString(class_name()) &&
           VerifyOffsetRequired(verifier, VT_SOURCE_CODE) &&
           verifier.VerifyString(source_code()) &&
           VerifyField<uint16_t>(verifier, VT_FILE_NAME_ID) &&
           VerifyOffsetRequired(verifier, VT_CTOR) &&
           verifier.VerifyTable(ctor()) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           verifier.VerifyVectorOfTables(methods()) &&
           verifier.EndTable();
  }
};

struct MessageClassProtoBuilder {
  typedef MessageClassProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_class_id(uint16_t class_id) {
    fbb_.AddElement<uint16_t>(MessageClassProto::VT_CLASS_ID, class_id, 0);
  }
  void add_class_name(flatbuffers::Offset<flatbuffers::String> class_name) {
    fbb_.AddOffset(MessageClassProto::VT_CLASS_NAME, class_name);
  }
  void add_source_code(flatbuffers::Offset<flatbuffers::String> source_code) {
    fbb_.AddOffset(MessageClassProto::VT_SOURCE_CODE, source_code);
  }
  void add_file_name_id(uint16_t file_name_id) {
    fbb_.AddElement<uint16_t>(MessageClassProto::VT_FILE_NAME_ID, file_name_id, 0);
  }
  void add_ctor(flatbuffers::Offset<ConstructorProto> ctor) {
    fbb_.AddOffset(MessageClassProto::VT_CTOR, ctor);
  }
  void add_methods(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MethodProto>>> methods) {
    fbb_.AddOffset(MessageClassProto::VT_METHODS, methods);
  }
  explicit MessageClassProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MessageClassProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageClassProto>(end);
    fbb_.Required(o, MessageClassProto::VT_CLASS_NAME);
    fbb_.Required(o, MessageClassProto::VT_SOURCE_CODE);
    fbb_.Required(o, MessageClassProto::VT_CTOR);
    return o;
  }
};

inline flatbuffers::Offset<MessageClassProto> CreateMessageClassProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    flatbuffers::Offset<flatbuffers::String> class_name = 0,
    flatbuffers::Offset<flatbuffers::String> source_code = 0,
    uint16_t file_name_id = 0,
    flatbuffers::Offset<ConstructorProto> ctor = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MethodProto>>> methods = 0) {
  MessageClassProtoBuilder builder_(_fbb);
  builder_.add_methods(methods);
  builder_.add_ctor(ctor);
  builder_.add_source_code(source_code);
  builder_.add_class_name(class_name);
  builder_.add_file_name_id(file_name_id);
  builder_.add_class_id(class_id);
  return builder_.Finish();
}

struct MessageClassProto::Traits {
  using type = MessageClassProto;
  static auto constexpr Create = CreateMessageClassProto;
};

inline flatbuffers::Offset<MessageClassProto> CreateMessageClassProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t class_id = 0,
    const char *class_name = nullptr,
    const char *source_code = nullptr,
    uint16_t file_name_id = 0,
    flatbuffers::Offset<ConstructorProto> ctor = 0,
    const std::vector<flatbuffers::Offset<MethodProto>> *methods = nullptr) {
  auto class_name__ = class_name ? _fbb.CreateString(class_name) : 0;
  auto source_code__ = source_code ? _fbb.CreateString(source_code) : 0;
  auto methods__ = methods ? _fbb.CreateVector<flatbuffers::Offset<MethodProto>>(*methods) : 0;
  return CreateMessageClassProto(
      _fbb,
      class_id,
      class_name__,
      source_code__,
      file_name_id,
      ctor,
      methods__);
}

struct FreeFunctionProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FreeFunctionProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE_CODE = 4,
    VT_FUNCTION_NAME = 6,
    VT_ARGUMENTS = 8,
    VT_RETURN_TYPE = 10
  };
  const flatbuffers::String *source_code() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCE_CODE);
  }
  const flatbuffers::String *function_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FUNCTION_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>> *>(VT_ARGUMENTS);
  }
  const flatbuffers::String *return_type() const {
    return GetPointer<const flatbuffers::String *>(VT_RETURN_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SOURCE_CODE) &&
           verifier.VerifyString(source_code()) &&
           VerifyOffset(verifier, VT_FUNCTION_NAME) &&
           verifier.VerifyString(function_name()) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           VerifyOffset(verifier, VT_RETURN_TYPE) &&
           verifier.VerifyString(return_type()) &&
           verifier.EndTable();
  }
};

struct FreeFunctionProtoBuilder {
  typedef FreeFunctionProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_source_code(flatbuffers::Offset<flatbuffers::String> source_code) {
    fbb_.AddOffset(FreeFunctionProto::VT_SOURCE_CODE, source_code);
  }
  void add_function_name(flatbuffers::Offset<flatbuffers::String> function_name) {
    fbb_.AddOffset(FreeFunctionProto::VT_FUNCTION_NAME, function_name);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>>> arguments) {
    fbb_.AddOffset(FreeFunctionProto::VT_ARGUMENTS, arguments);
  }
  void add_return_type(flatbuffers::Offset<flatbuffers::String> return_type) {
    fbb_.AddOffset(FreeFunctionProto::VT_RETURN_TYPE, return_type);
  }
  explicit FreeFunctionProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FreeFunctionProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FreeFunctionProto>(end);
    fbb_.Required(o, FreeFunctionProto::VT_SOURCE_CODE);
    return o;
  }
};

inline flatbuffers::Offset<FreeFunctionProto> CreateFreeFunctionProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> source_code = 0,
    flatbuffers::Offset<flatbuffers::String> function_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MethodArgumentProto>>> arguments = 0,
    flatbuffers::Offset<flatbuffers::String> return_type = 0) {
  FreeFunctionProtoBuilder builder_(_fbb);
  builder_.add_return_type(return_type);
  builder_.add_arguments(arguments);
  builder_.add_function_name(function_name);
  builder_.add_source_code(source_code);
  return builder_.Finish();
}

struct FreeFunctionProto::Traits {
  using type = FreeFunctionProto;
  static auto constexpr Create = CreateFreeFunctionProto;
};

inline flatbuffers::Offset<FreeFunctionProto> CreateFreeFunctionProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *source_code = nullptr,
    const char *function_name = nullptr,
    const std::vector<flatbuffers::Offset<MethodArgumentProto>> *arguments = nullptr,
    const char *return_type = nullptr) {
  auto source_code__ = source_code ? _fbb.CreateString(source_code) : 0;
  auto function_name__ = function_name ? _fbb.CreateString(function_name) : 0;
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<MethodArgumentProto>>(*arguments) : 0;
  auto return_type__ = return_type ? _fbb.CreateString(return_type) : 0;
  return CreateFreeFunctionProto(
      _fbb,
      source_code__,
      function_name__,
      arguments__,
      return_type__);
}

struct FreeClassProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FreeClassProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CTOR = 4,
    VT_SOURCE_CODE = 6,
    VT_CLASS_NAME = 8,
    VT_METHODS = 10
  };
  const ConstructorProto *ctor() const {
    return GetPointer<const ConstructorProto *>(VT_CTOR);
  }
  const flatbuffers::String *source_code() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCE_CODE);
  }
  const flatbuffers::String *class_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CLASS_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MethodProto>> *methods() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MethodProto>> *>(VT_METHODS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CTOR) &&
           verifier.VerifyTable(ctor()) &&
           VerifyOffsetRequired(verifier, VT_SOURCE_CODE) &&
           verifier.VerifyString(source_code()) &&
           VerifyOffset(verifier, VT_CLASS_NAME) &&
           verifier.VerifyString(class_name()) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           verifier.VerifyVectorOfTables(methods()) &&
           verifier.EndTable();
  }
};

struct FreeClassProtoBuilder {
  typedef FreeClassProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ctor(flatbuffers::Offset<ConstructorProto> ctor) {
    fbb_.AddOffset(FreeClassProto::VT_CTOR, ctor);
  }
  void add_source_code(flatbuffers::Offset<flatbuffers::String> source_code) {
    fbb_.AddOffset(FreeClassProto::VT_SOURCE_CODE, source_code);
  }
  void add_class_name(flatbuffers::Offset<flatbuffers::String> class_name) {
    fbb_.AddOffset(FreeClassProto::VT_CLASS_NAME, class_name);
  }
  void add_methods(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MethodProto>>> methods) {
    fbb_.AddOffset(FreeClassProto::VT_METHODS, methods);
  }
  explicit FreeClassProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FreeClassProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FreeClassProto>(end);
    fbb_.Required(o, FreeClassProto::VT_CTOR);
    fbb_.Required(o, FreeClassProto::VT_SOURCE_CODE);
    return o;
  }
};

inline flatbuffers::Offset<FreeClassProto> CreateFreeClassProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ConstructorProto> ctor = 0,
    flatbuffers::Offset<flatbuffers::String> source_code = 0,
    flatbuffers::Offset<flatbuffers::String> class_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MethodProto>>> methods = 0) {
  FreeClassProtoBuilder builder_(_fbb);
  builder_.add_methods(methods);
  builder_.add_class_name(class_name);
  builder_.add_source_code(source_code);
  builder_.add_ctor(ctor);
  return builder_.Finish();
}

struct FreeClassProto::Traits {
  using type = FreeClassProto;
  static auto constexpr Create = CreateFreeClassProto;
};

inline flatbuffers::Offset<FreeClassProto> CreateFreeClassProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ConstructorProto> ctor = 0,
    const char *source_code = nullptr,
    const char *class_name = nullptr,
    const std::vector<flatbuffers::Offset<MethodProto>> *methods = nullptr) {
  auto source_code__ = source_code ? _fbb.CreateString(source_code) : 0;
  auto class_name__ = class_name ? _fbb.CreateString(class_name) : 0;
  auto methods__ = methods ? _fbb.CreateVector<flatbuffers::Offset<MethodProto>>(*methods) : 0;
  return CreateFreeClassProto(
      _fbb,
      ctor,
      source_code__,
      class_name__,
      methods__);
}

struct WorkerIndexProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WorkerIndexProtoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_DEBUG = 4,
    VT_WORKER_ID = 6,
    VT_WORKER_VERSION = 8,
    VT_WORKER_NAME = 10,
    VT_FILE_NAMES = 12,
    VT_WORKER_LANGUAGE = 14,
    VT_FREE_FUNCTIONS = 16,
    VT_FREE_CLASSES = 18,
    VT_SERVICE_CLASSES = 20,
    VT_DATA_CLASSES = 22,
    VT_MESSAGE_CLASSES = 24
  };
  bool is_debug() const {
    return GetField<uint8_t>(VT_IS_DEBUG, 0) != 0;
  }
  uint64_t worker_id() const {
    return GetField<uint64_t>(VT_WORKER_ID, 0);
  }
  uint64_t worker_version() const {
    return GetField<uint64_t>(VT_WORKER_VERSION, 0);
  }
  const flatbuffers::String *worker_name() const {
    return GetPointer<const flatbuffers::String *>(VT_WORKER_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<WorkerFileNameProto>> *file_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<WorkerFileNameProto>> *>(VT_FILE_NAMES);
  }
  int8_t worker_language() const {
    return GetField<int8_t>(VT_WORKER_LANGUAGE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FreeFunctionProto>> *free_functions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FreeFunctionProto>> *>(VT_FREE_FUNCTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FreeClassProto>> *free_classes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FreeClassProto>> *>(VT_FREE_CLASSES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ServiceClassProto>> *service_classes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ServiceClassProto>> *>(VT_SERVICE_CLASSES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DataClassProto>> *data_classes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DataClassProto>> *>(VT_DATA_CLASSES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MessageClassProto>> *message_classes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MessageClassProto>> *>(VT_MESSAGE_CLASSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_DEBUG) &&
           VerifyField<uint64_t>(verifier, VT_WORKER_ID) &&
           VerifyField<uint64_t>(verifier, VT_WORKER_VERSION) &&
           VerifyOffsetRequired(verifier, VT_WORKER_NAME) &&
           verifier.VerifyString(worker_name()) &&
           VerifyOffsetRequired(verifier, VT_FILE_NAMES) &&
           verifier.VerifyVector(file_names()) &&
           verifier.VerifyVectorOfTables(file_names()) &&
           VerifyField<int8_t>(verifier, VT_WORKER_LANGUAGE) &&
           VerifyOffset(verifier, VT_FREE_FUNCTIONS) &&
           verifier.VerifyVector(free_functions()) &&
           verifier.VerifyVectorOfTables(free_functions()) &&
           VerifyOffset(verifier, VT_FREE_CLASSES) &&
           verifier.VerifyVector(free_classes()) &&
           verifier.VerifyVectorOfTables(free_classes()) &&
           VerifyOffset(verifier, VT_SERVICE_CLASSES) &&
           verifier.VerifyVector(service_classes()) &&
           verifier.VerifyVectorOfTables(service_classes()) &&
           VerifyOffset(verifier, VT_DATA_CLASSES) &&
           verifier.VerifyVector(data_classes()) &&
           verifier.VerifyVectorOfTables(data_classes()) &&
           VerifyOffset(verifier, VT_MESSAGE_CLASSES) &&
           verifier.VerifyVector(message_classes()) &&
           verifier.VerifyVectorOfTables(message_classes()) &&
           verifier.EndTable();
  }
};

struct WorkerIndexProtoBuilder {
  typedef WorkerIndexProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_debug(bool is_debug) {
    fbb_.AddElement<uint8_t>(WorkerIndexProto::VT_IS_DEBUG, static_cast<uint8_t>(is_debug), 0);
  }
  void add_worker_id(uint64_t worker_id) {
    fbb_.AddElement<uint64_t>(WorkerIndexProto::VT_WORKER_ID, worker_id, 0);
  }
  void add_worker_version(uint64_t worker_version) {
    fbb_.AddElement<uint64_t>(WorkerIndexProto::VT_WORKER_VERSION, worker_version, 0);
  }
  void add_worker_name(flatbuffers::Offset<flatbuffers::String> worker_name) {
    fbb_.AddOffset(WorkerIndexProto::VT_WORKER_NAME, worker_name);
  }
  void add_file_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WorkerFileNameProto>>> file_names) {
    fbb_.AddOffset(WorkerIndexProto::VT_FILE_NAMES, file_names);
  }
  void add_worker_language(int8_t worker_language) {
    fbb_.AddElement<int8_t>(WorkerIndexProto::VT_WORKER_LANGUAGE, worker_language, 0);
  }
  void add_free_functions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FreeFunctionProto>>> free_functions) {
    fbb_.AddOffset(WorkerIndexProto::VT_FREE_FUNCTIONS, free_functions);
  }
  void add_free_classes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FreeClassProto>>> free_classes) {
    fbb_.AddOffset(WorkerIndexProto::VT_FREE_CLASSES, free_classes);
  }
  void add_service_classes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ServiceClassProto>>> service_classes) {
    fbb_.AddOffset(WorkerIndexProto::VT_SERVICE_CLASSES, service_classes);
  }
  void add_data_classes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataClassProto>>> data_classes) {
    fbb_.AddOffset(WorkerIndexProto::VT_DATA_CLASSES, data_classes);
  }
  void add_message_classes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MessageClassProto>>> message_classes) {
    fbb_.AddOffset(WorkerIndexProto::VT_MESSAGE_CLASSES, message_classes);
  }
  explicit WorkerIndexProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WorkerIndexProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerIndexProto>(end);
    fbb_.Required(o, WorkerIndexProto::VT_WORKER_NAME);
    fbb_.Required(o, WorkerIndexProto::VT_FILE_NAMES);
    return o;
  }
};

inline flatbuffers::Offset<WorkerIndexProto> CreateWorkerIndexProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_debug = false,
    uint64_t worker_id = 0,
    uint64_t worker_version = 0,
    flatbuffers::Offset<flatbuffers::String> worker_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WorkerFileNameProto>>> file_names = 0,
    int8_t worker_language = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FreeFunctionProto>>> free_functions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FreeClassProto>>> free_classes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ServiceClassProto>>> service_classes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataClassProto>>> data_classes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MessageClassProto>>> message_classes = 0) {
  WorkerIndexProtoBuilder builder_(_fbb);
  builder_.add_worker_version(worker_version);
  builder_.add_worker_id(worker_id);
  builder_.add_message_classes(message_classes);
  builder_.add_data_classes(data_classes);
  builder_.add_service_classes(service_classes);
  builder_.add_free_classes(free_classes);
  builder_.add_free_functions(free_functions);
  builder_.add_file_names(file_names);
  builder_.add_worker_name(worker_name);
  builder_.add_worker_language(worker_language);
  builder_.add_is_debug(is_debug);
  return builder_.Finish();
}

struct WorkerIndexProto::Traits {
  using type = WorkerIndexProto;
  static auto constexpr Create = CreateWorkerIndexProto;
};

inline flatbuffers::Offset<WorkerIndexProto> CreateWorkerIndexProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_debug = false,
    uint64_t worker_id = 0,
    uint64_t worker_version = 0,
    const char *worker_name = nullptr,
    const std::vector<flatbuffers::Offset<WorkerFileNameProto>> *file_names = nullptr,
    int8_t worker_language = 0,
    const std::vector<flatbuffers::Offset<FreeFunctionProto>> *free_functions = nullptr,
    const std::vector<flatbuffers::Offset<FreeClassProto>> *free_classes = nullptr,
    const std::vector<flatbuffers::Offset<ServiceClassProto>> *service_classes = nullptr,
    const std::vector<flatbuffers::Offset<DataClassProto>> *data_classes = nullptr,
    const std::vector<flatbuffers::Offset<MessageClassProto>> *message_classes = nullptr) {
  auto worker_name__ = worker_name ? _fbb.CreateString(worker_name) : 0;
  auto file_names__ = file_names ? _fbb.CreateVector<flatbuffers::Offset<WorkerFileNameProto>>(*file_names) : 0;
  auto free_functions__ = free_functions ? _fbb.CreateVector<flatbuffers::Offset<FreeFunctionProto>>(*free_functions) : 0;
  auto free_classes__ = free_classes ? _fbb.CreateVector<flatbuffers::Offset<FreeClassProto>>(*free_classes) : 0;
  auto service_classes__ = service_classes ? _fbb.CreateVector<flatbuffers::Offset<ServiceClassProto>>(*service_classes) : 0;
  auto data_classes__ = data_classes ? _fbb.CreateVector<flatbuffers::Offset<DataClassProto>>(*data_classes) : 0;
  auto message_classes__ = message_classes ? _fbb.CreateVector<flatbuffers::Offset<MessageClassProto>>(*message_classes) : 0;
  return CreateWorkerIndexProto(
      _fbb,
      is_debug,
      worker_id,
      worker_version,
      worker_name__,
      file_names__,
      worker_language,
      free_functions__,
      free_classes__,
      service_classes__,
      data_classes__,
      message_classes__);
}

inline const WorkerIndexProto *GetWorkerIndexProto(const void *buf) {
  return flatbuffers::GetRoot<WorkerIndexProto>(buf);
}

inline const WorkerIndexProto *GetSizePrefixedWorkerIndexProto(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<WorkerIndexProto>(buf);
}

inline bool VerifyWorkerIndexProtoBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<WorkerIndexProto>(nullptr);
}

inline bool VerifySizePrefixedWorkerIndexProtoBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<WorkerIndexProto>(nullptr);
}

inline void FinishWorkerIndexProtoBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<WorkerIndexProto> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedWorkerIndexProtoBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<WorkerIndexProto> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_WORKERINDEXPROTO_H_
